/* $Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/regtape/vote.dc,v 1.1 1993-03-10 10:27:54 mar Exp $
 */

#include <stdio.h>
#include <strings.h>
#include <ctype.h>
#include <sys/time.h>
#include <moira.h>
#include <moira_site.h>
EXEC SQL INCLUDE sqlca;


struct entry {
    char *line;
    char last[19];
    char first[14];
    char middle[11];
    char class;
    char login[9];
};

char *whoami;
int debug;


main(argc, argv)
int argc;
char **argv;
{
    FILE *in;
    struct entry *e, *get_next_entry();
    int i, wait = 0;
    char buf[BUFSIZ], *file = NULL, *p, *p1;

    debug = 0;
    whoami = rindex(argv[0], '/');
    if (whoami)
      whoami++;
    else
      whoami = argv[0];

    for (i = 1; i < argc; i++) {
	if (!strcmp(argv[i], "-w"))
	  wait++;
	else if (!strcmp(argv[i], "-D"))
	  setenv("ING_SET", "set printqry");
	else if (!strcmp(argv[i], "-d"))
	  debug = 1;
	else if (file != NULL)
	  fprintf(stderr, "Usage: %s [-w] [-D] [-n] inputfile\n", whoami);
	else
	  file = argv[i];
    }

    in = fopen(file, "r");
    if (in == NULL) {
	fprintf(stderr, "Unable to open %s for input\n", file);
	exit(1);
    }

    setlinebuf(stdout);
    setlinebuf(stderr);

    EXEC SQL CONNECT moira;
    if (sqlca.sqlcode != 0) {
	com_err(whoami, 0, "ingres error %d", sqlca.sqlcode);
	exit(1);
    }

    while (e = get_next_entry(in)) {
	i = process_entry(e);
	EXEC SQL COMMIT WORK;
	if (i == 0) {
	    p = &(e->line[46]);
	    for (p1 = e->login; *p1; p1++)
	      *p++ = *p1;
	    for (; p < &(e->line[54]); p++)
	      *p = ' ';
	    fputs(e->line, stdout);
	}
	if (wait) {
	    printf("Next");
	    fflush(stdout);
	    gets(buf);
	}
    }

    exit(0);
}



struct entry *get_next_entry(in)
FILE *in;
{
    static struct entry e;
    static char buf[BUFSIZ];

    if (fgets(buf, sizeof(buf), in) == NULL)
      return((struct entry *)NULL);

    e.line = &buf[0];
    strncpy(e.last, &buf[4], 18);
    e.last[18] = 0;
    strncpy(e.first, &buf[22], 13);
    e.first[13] = 0;
    strncpy(e.middle, &buf[35], 10);
    e.middle[10] = 0;
    e.class = buf[45];
    return(&e);
}


process_entry(e)
struct entry *e;
{
    int dummy;
    static int nyear = 0;
    EXEC SQL BEGIN DECLARE SECTION;
    char *last, *first, *middle, *login, class[10];
    EXEC SQL END DECLARE SECTION;

    if (nyear == 0) {
	struct tm *tm;
	struct timeval tv;

	gettimeofday(&tv, NULL);
	tm = localtime(&tv.tv_sec);
	nyear = tm->tm_year;
	if (tm->tm_mon > 5)
	  nyear++;
    }

    LookForSt(e->last);
    LookForO(e->last);
    LookForJrAndIII(e->last, &dummy, &dummy, &dummy, &dummy, &dummy, &dummy);
    LookForJrAndIII(e->first, &dummy, &dummy, &dummy, &dummy, &dummy, &dummy);
    FixCase(e->last);
    FixCase(e->first);
    FixCase(e->middle);

    last = e->last;
    first = e->first;
    middle = e->middle;
    login = e->login;

    if (debug)
      printf("Got last: %s, first %s, middle %s, class %c\n",
	     last, first, middle, e->class);
    EXEC SQL REPEATED SELECT login INTO :login FROM users
      WHERE last = :last and first = :first and middle = :middle and
	status != 3;
    if (sqlca.sqlcode != 0) {
	if (sqlca.sqlcode == 100) {
	    EXEC SQL REPEATED SELECT login INTO :login FROM users
	      WHERE last = :last and first = :first and status != 3;
	    if (sqlca.sqlcode != 0) {
		fprintf(stderr, "User %s %s not found.\n", strtrim(e->first),
			strtrim(e->last));
		return(-1);
	    }
	} else if (sqlca.sqlcode == -40100) {
	    sprintf(class, "%d", nyear + 4 - e->class - '0' + 1900);
	    EXEC SQL REPEATED SELECT login INTO :login FROM users
	      WHERE last = :last and first = :first and middle = :middle
		and type = :class and status != 3;
	    if (sqlca.sqlcode != 0) {
		fprintf(stderr, "Could not match class on %s %s %c (Error %d)\n",
			strtrim(e->first), strtrim(e->last), e->class, sqlca.sqlcode);
		return(-1);
	    }
	} else {
	    fprintf(stderr, "Error %d on %s\n", sqlca.sqlcode, e->line);
	    return(-1);
	}
    }
    strncpy(e->login, login, 8);
    e->login[8] = 0;
    if (debug)
      printf("Got username %s\n", login);
    return(0);
}
