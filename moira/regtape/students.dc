/* $Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/regtape/students.dc,v 1.9 1990-03-19 21:55:48 mar Exp $
 */

#include <stdio.h>
#include <strings.h>
#include <ctype.h>
#include <sys/time.h>
#include <moira.h>
#include <moira_site.h>


##define WHO 11859		/* root */
##define PROG "stu-tape"

#define MAX_ID_VALUE	32766
#define MIN_ID_VALUE	101

/* File format is:

0-29	name
30-38	id number
50-54	school code
55-79   year
80-109  address
110-124 room
125-144 city
145-158 state
159-168 dorm phone
169-212 home address
213-232 home city
243-251 mit phone (?)
*/

#define LOC_NAME 0
#define LOC_ID 30
#define LOC_COURSE 50
#define LOC_YEAR 55
#define LOC_ADDRESS 80
#define LOC_DORM_ROOM 110
#define LOC_CITY 125
#define LOC_STATE 145
#define LOC_DORM_PHONE 159
#define LOC_MIT_PHONE1 243

#define LEN_NAME 29
#define LEN_ID 9
#define LEN_COURSE 3
#define LEN_YEAR 23
#define LEN_ADDRESS 26
#define LEN_DORM_ROOM 14
#define LEN_CITY 19
#define LEN_STATE 12
#define LEN_DPHONE 9
#define LEN_MPHONE 9

struct entry {
    char *last;
    char *first;
    char *middle;
    char *title;
    char *id;
    char *eid;
    char *course;
    char *year;
    char *address;
    char *dorm;
    char *city;
    char *state;
    char *dphone;
    char *mphone;
    char *class;
};


char *whoami;
int newfinger = 0;


main(argc, argv)
int argc;
char **argv;
##{
    FILE *in;
    struct entry *e, *get_next_entry();
    int i, wait = 0;
    char buf[BUFSIZ], *file = NULL;

    whoami = rindex(argv[0], '/');
    if (whoami)
      whoami++;
    else
      whoami = argv[0];

    for (i = 1; i < argc; i++) {
	if (!strcmp(argv[i], "-w"))
	  wait++;
	else if (!strcmp(argv[i], "-D"))
	  setenv("ING_SET", "set printqry");
	else if (!strcmp(argv[i], "-n"))
	  newfinger++;
	else if (file != NULL)
	  fprintf(stderr, "Usage: %s [-w] [-D] [-n] inputfile\n", whoami);
	else
	  file = argv[i];
    }

    in = fopen(file, "r");
    if (in == NULL) {
	fprintf(stderr, "Unable to open %s for input\n", file);
	exit(1);
    }

##  ingres sms
##  range of u is users

    while (e = get_next_entry(in)) {
	process_entry(e);
	if (wait) {
	    printf("Next");
	    fflush(stdout);
	    gets(buf);
	}
    }

##  exit
    exit(0);
##}


struct entry *get_next_entry(in)
FILE *in;
{
    static struct entry e;
    static char buf[BUFSIZ], eid[16], classbuf[10], titlebuf[12];
    static int year = 0;
    int ends_jr, ends_iii, ends_iv, ends_sr;
    char *p;

    if (year == 0) {
	struct tm *tm;
	struct timeval tv;

	gettimeofday(&tv, NULL);
	tm = localtime(&tv.tv_sec);
	year = tm->tm_year;
	if (tm->tm_mon > 5)
	  year++;
    }

    if (fgets(buf, sizeof(buf), in) == NULL)
      return((struct entry *)NULL);
    buf[LEN_NAME] = 0;
    p = index(&buf[LOC_NAME], ',');
    if (p)
      *p = 0;
    e.last = strtrim(&buf[LOC_NAME]);
    if (p) {
	e.first = p + 2;
	if (p = index(e.first, ' ')) {
	    *p = 0;
	    e.middle = strtrim(p + 1);
	} else
	  e.middle = "";
    } else
      e.first = "";
    e.first = strtrim(e.first);
    ends_jr = ends_iii = ends_iv = ends_sr = 0;
    LookForSt(e.last);
    LookForO(e.last);
    LookForJrAndIII(e.last, &ends_sr, &ends_jr, &ends_iii, &ends_iv);
    LookForJrAndIII(e.first, &ends_sr, &ends_jr, &ends_iii, &ends_iv);
    FixCase(e.last);
    FixCase(e.first);
    FixCase(e.middle);
    e.title = titlebuf;
    titlebuf[0] = 0;
    AppendJrOrIII(titlebuf, &ends_sr, &ends_jr, &ends_iii, &ends_iv);

    e.id = &buf[LOC_ID];
    e.id[LEN_ID] = 0;
    e.eid = eid;
    EncryptID(e.eid, e.id, e.first, e.last);

    e.course = &buf[LOC_COURSE];
    e.course[LEN_COURSE] = 0;
    e.year = &buf[LOC_YEAR];
    e.year[LEN_YEAR] = 0;
    if (e.year[0] == 'G')
      e.class = "G";
    else {
	e.class = classbuf;
	sprintf(classbuf, "%d", year + 4 - atoi(e.year) + 1900);
    }
    e.address = &buf[LOC_ADDRESS];
    e.address[LEN_ADDRESS] = 0;
    e.dorm = &buf[LOC_DORM_ROOM];
    e.dorm[LEN_DORM_ROOM] = 0;
    e.city = &buf[LOC_CITY];
    e.city[LEN_CITY] = 0;
    e.state = &buf[LOC_STATE];
    e.state[LEN_STATE] = 0;
    e.dphone = &buf[LOC_DORM_PHONE];
    e.dphone[LEN_DPHONE] = 0;
    e.mphone = &buf[LOC_MIT_PHONE1];
    e.mphone[LEN_MPHONE] = 0;
    return(&e);
}


process_entry(e)
struct entry *e;
##{
    int changed, nochange;
    char buf[BUFSIZ], *from, *to;
##  char *first, *last, *eid;
##  char class[9], haddr[81], hphone[17], ophone[13], dept[13];
##  int id;

    first = e->first;
    if (strlen(first) > 16)
      first[16] = 0;
    last = e->last;
    if (strlen(last) > 16)
      last[16] = 0;
    eid = e->eid;
    id = 0;
##  repeat retrieve (id = u.users_id, class = u.mit_year, haddr = u.home_addr,
##	      hphone = u.home_phone, ophone = u.office_phone,
##	      dept = u.mit_dept)
##	where u.#last = @last and u.#first = @first and u.mit_id = @eid
    if (id == 0) {
	newuser(e);
	return;
    }
    if (strcmp(e->class, strtrim(class)) &&
	strcmp(class, "STAFF") && strcmp(class, "SIPB")) {
	com_err(whoami, 0, "updating class for user %s %s from %s to %s",
		first, last, class, e->class);
	strcpy(class, e->class);
##	repeat replace u (mit_year = @class,
##		   modtime = "now", modby = WHO, modwith = PROG)
##	    where u.users_id = @id
    }
    changed = nochange = 0;
    strcpy(buf, strtrim(e->address));
    e->dorm = strtrim(e->dorm);
    if (*e->dorm) {
	strcat(buf, " ");
	strcat(buf, e->dorm);
    }
    e->city = strtrim(e->city);
    if (*e->city) {
	strcat(buf, " ");
	strcat(buf, e->city);
    }
    FixCase(buf);
    e->state = strtrim(e->state);
    if (*e->state) {
	strcat(buf, " ");
	strcat(buf, e->state);
    }
    while (to = index(buf, ','))
      *to = ';';
    while (to = index(buf, ':'))
      *to = ';';
    if (newfinger) {
	if (haddr[0] == ' ') {
	    strncpy(haddr, buf, 80);
	    haddr[80] = 0;
	    changed++;
	} else if (strncmp(strtrim(haddr), buf, 80))
	  nochange++;
    } else {
	if (strncmp(strtrim(haddr), buf, 80))
	  changed++;
	strncpy(haddr, buf, 80);
	haddr[80] = 0;
    }
    from = e->dphone;
    to = buf;
    while (*from) {
	if (isdigit(*from))
	  *to++ = *from;
	from++;
    }
    *to = 0;
    if (newfinger) {
	if (hphone[0] == ' ') {
	    strncpy(hphone, buf, 16);
	    hphone[16] = 0;
	} else if (strncmp(strtrim(hphone), buf, 16))
	  nochange++;
    } else {
	if (strncmp(strtrim(hphone), buf, 16))
	  changed++;
	strncpy(hphone, buf, 16);
	hphone[16] = 0;
    }
    from = e->mphone;
    to = buf;
    while (*from) {
	if (isdigit(*from))
	  *to++ = *from;
	from++;
    }
    *to = 0;
    if (newfinger) {
	if (ophone[0] == ' ') {
	    strncpy(ophone, buf, 12);
	    ophone[12] = 0;
	} else if (strncmp(strtrim(ophone), buf, 12))
	  nochange++;
    } else {
	if (strncmp(strtrim(ophone), buf, 12))
	  changed++;
	strncpy(ophone, buf, 12);
	ophone[12] = 0;
    }
    e->course = strtrim(e->course);
    if (newfinger) {
	if (dept[0] == ' ') {
	    strncpy(dept, e->course, 12);
	    dept[12] = 0;
	} else if (strncmp(strtrim(dept), e->course, 11))
	  nochange++;
    } else {
	if (strncmp(strtrim(dept), e->course, 11))
	  changed++;
	strncpy(dept, e->course, 12);
	dept[12] = 0;
    }
    if (changed) {
	com_err(whoami, 0, "updating finger for %s %s", first, last);
##	repeat replace u (home_addr = @haddr, home_phone = @hphone,
##		   office_phone = @ophone, #mit_dept = @dept,
##		   fmodtime = "now", fmodby = WHO, fmodwith = PROG)
##	    where u.users_id = @id
    } else if (nochange)
      com_err(whoami, 0, "NOT updating finger for %s %s", first, last);
##}


newuser(e)
struct entry *e;
##{
    char buf[512], *from, *to;
##  int id, uid;
##  char *last, *first, *class, *middle, login[9], *eid, fullname[65];
##  char haddr[81], hphone[17], ophone[13], dept[13];


    strcpy(buf, strtrim(e->address));
    if (*e->dorm) {
	strcat(buf, " ");
	strcat(buf, strtrim(e->dorm));
    }
    if (*e->city) {
	strcat(buf, " ");
	strcat(buf, strtrim(e->city));
    }
    if (*e->state) {
	strcat(buf, " ");
	strcat(buf, strtrim(e->state));
    }
    strncpy(haddr, buf, 80);
    from = e->dphone;
    to = buf;
    while (*from) {
	if (isdigit(*from))
	  *to++ = *from;
	from++;
    }
    *to = 0;
    strncpy(hphone, buf, 16);
    from = e->mphone;
    to = buf;
    while (*from) {
	if (isdigit(*from))
	  *to++ = *from;
	from++;
    }
    *to = 0;
    strncpy(ophone, buf, 12);
    e->course = strtrim(e->course);
    strncpy(dept, e->course, 12);

    
    id = set_next_object_id("users_id");
    uid = set_next_object_id("uid");
    sprintf(login, "#%d", uid);
    last = e->last;
    first = e->first;
    middle = e->middle;
    eid = e->eid;
    class = e->class;
    if (*middle)
      sprintf(fullname, "%s %s %s", first, middle, last);
    else
      sprintf(fullname, "%s %s", first, last);
    
##  append users (#login = login, users_id = id, #uid = uid, shell = "/bin/csh",
##		  #last = last, #first = first, #middle = middle, status = 0,
##		  #mit_id = eid, #mit_year = class,
##		  modtime = "now", modby = WHO, modwith = PROG,
##		  #fullname = fullname, home_addr = haddr, home_phone = hphone,
##		  office_phone = ophone, #mit_dept = dept,
##		  fmodtime = "now", fmodby = WHO, fmodwith = PROG,
##		  potype = "NONE")
    com_err(whoami, 0, "adding user %s %s", e->first, e->last);
##}


set_next_object_id(object)
    char *object;
##{
##  char *name;
##  int rowcount, exists, value;

    name = object;
##  begin transaction
##  repeat retrieve (value = values.#value) where values.#name = @name
##  inquire_equel(rowcount = "rowcount")
    if (rowcount != 1) {
##	abort
	return(0);
    }

##  retrieve (exists = any(users.name where users.name = value))
##  inquire_equel(rowcount = "rowcount")
    if (rowcount != 1) {
##	abort
	return(0);
    }
    while (exists) {
	value++;
	if (value > MAX_ID_VALUE)
	    value = MIN_ID_VALUE;
##	retrieve (exists = any(users.name where users.name = value))
    }

##  repeat replace values (#value = @value) where values.#name = @name
##  end transaction
    return(value);
##}


