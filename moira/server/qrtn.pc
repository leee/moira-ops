/*
 *	$Source: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/server/qrtn.pc,v $
 *	$Author: danw $
 *	$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/server/qrtn.pc,v 2.4.2.2 1997-10-03 17:31:19 danw Exp $
 *
 *	Copyright (C) 1987, 1988 by the Massachusetts Institute of Technology
 *	For copying and distribution information, please see the file
 *	<mit-copyright.h>.
 * 
 */

#ifndef lint
static char *rcsid_qrtn_dc = "$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/server/qrtn.pc,v 2.4.2.2 1997-10-03 17:31:19 danw Exp $";
#endif lint

#include <mit-copyright.h>
#include <string.h>
#include "mr_server.h"
#include "query.h"
EXEC SQL INCLUDE sqlca;  /* SQL Communications Area */
EXEC SQL INCLUDE sqlda;  /* SQL Descriptor Area */
#include "qrtn.h"

SQLDA *mr_sqlda;
EXEC SQL BEGIN DECLARE SECTION; 
int mr_sig_length;
int idummy;                            
char cdummy[MR_CDUMMY_LEN];            
char stmt_buf[MR_STMTBUF_LEN];
EXEC SQL END DECLARE SECTION; 

char *Argv[QMAXARGS];
extern char *table_name[];
extern char *sqlbuffer[QMAXARGS];

int dbms_errno = 0;
int mr_errcode = 0;
EXEC SQL BEGIN DECLARE SECTION; 
int query_timeout = 30;
char *database = "moira";
EXEC SQL END DECLARE SECTION;
extern char *whoami;
extern FILE *journal;

int mr_verify_query(client *cl, struct query *q, int argc, char *argv_ro[]);
int do_retrieve(struct query *q, char *pqual, int (*action)(), char *actarg);
int do_update(struct query *q, char *argv[], char *qual,
	      int (*action)(), char *actarg);
int do_append(struct query *q, char *argv[], char *pqual,
	      int (*action)(), char *actarg);
int do_delete(struct query *q, char *qual,
	      int (*action)(), char *actarg);
char *build_sql_stmt(char *cmd, char *targetlist, char *argv[],
		     int argc, char *qual, char *sort);

/* from qvalidate.dc */
int validate_fields(struct query *q, char *argv[], struct valobj *vo, int n);
int validate_row(struct query *q, char *argv[], struct validate *v);


/*
 * dbmserr: Called when the DBMS indicates an error.
 */

void dbmserr(void)
{
    EXEC SQL BEGIN DECLARE SECTION; 
    char err_msg[256];
    EXEC SQL END DECLARE SECTION;
    int bufsize=256, msglength=0;

    dbms_errno = -sqlca.sqlcode;
    mr_errcode = MR_DBMS_ERR;
    com_err(whoami, MR_DBMS_ERR, " code %d\n", dbms_errno);
    sqlglm(err_msg, &bufsize, &msglength);
    err_msg[msglength]=0;
    com_err(whoami, 0, "SQL error text = %s", err_msg);
    critical_alert("MOIRA", "Moira server encountered DBMS ERROR %d\n%s",
		       dbms_errno, err_msg);
}

/* This is declarative, not executed.  Applies from here on, in this file. */
EXEC SQL WHENEVER SQLERROR DO dbmserr();

int mr_open_database(void)
{
    register int i;
    SQLDA *mr_alloc_sqlda();
    static first_open = 1;

    if (first_open) {
	first_open = 0;

	/* initialize local argv */
	for (i = 0; i < 16; i++)
	  Argv[i] = malloc(ARGLEN);

	mr_sqlda = mr_alloc_sqlda();       

	incremental_init();
	flush_cache();
    }
	
    dbms_errno = 0;
    mr_errcode = 0;

    /* open the database */
    EXEC SQL CONNECT :database IDENTIFIED BY :database;

    if(dbms_errno) 
        return(mr_errcode);

    EXEC SQL SELECT data_length INTO :mr_sig_length FROM user_tab_columns WHERE table_name='USERS' and column_name='SIGNATURE';
    EXEC SQL COMMIT WORK;
    if(dbms_errno)
        return(mr_errcode);

    return(MR_SUCCESS);
}

void mr_close_database(void)
{
    flush_cache();
    EXEC SQL COMMIT RELEASE;
}

int mr_check_access(cl, name, argc, argv_ro)
     client *cl;
     char *name, *argv_ro[];
     int argc;
{
    struct query *q;

    dbms_errno = 0;
    mr_errcode = 0;

    q = get_query_by_name(name, cl->args->mr_version_no);
    if (q == (struct query *)0)
	return(MR_NO_HANDLE);

    return(mr_verify_query(cl, q, argc, argv_ro));    
}

int mr_process_query(cl, name, argc, argv_ro, action, actarg)
     client *cl;
     char *name, *argv_ro[], *actarg;
     int argc, (*action)();
{
    register struct query *q;
    register int status;
    register struct validate *v;
    char *qual = NULL;
    EXEC SQL BEGIN DECLARE SECTION; 
    char *table;
    EXEC SQL END DECLARE SECTION; 
    struct save_queue *sq;

    dbms_errno = 0;
    mr_errcode = 0;

    /* list queries command */
    if (!strcmp(name, "_list_queries")) {
	list_queries(cl->args->mr_version_no, action, actarg);
	return(MR_SUCCESS);
    }

    /* help query command */
    if (!strcmp(name, "_help")) {
	if (argc < 1)
	    return(MR_ARGS);
	q = get_query_by_name(argv_ro[0], cl->args->mr_version_no);
	if (q == (struct query *)0) return(MR_NO_HANDLE);
	help_query(q, action, actarg);
	return(MR_SUCCESS);
    }

    /* get query structure, return error if named query does not exist */
    q = get_query_by_name(name, cl->args->mr_version_no);
    if (q == (struct query *)0) return(MR_NO_HANDLE);
    v = q->validate;

    /* setup argument vector, verify access and arguments */
    if ((status = mr_verify_query(cl, q, argc, argv_ro)) != MR_SUCCESS)
	goto out;

    /* perform any special query pre-processing */
    if (v && v->pre_rtn) {
	status = (*v->pre_rtn)(q, Argv, cl, 0);
	if (status != MR_SUCCESS)
	    goto out;
    }

    switch (q->type) {
    case RETRIEVE:
	/* for queries that do not permit wildcarding, check if row
	   uniquely exists */
	if (v && v->field) {
	    status = validate_row(q, Argv, v); 
	    if (status != MR_EXISTS) break;
	}

	/* if there is a followup routine, then we must save the results */
	/* of the first query for use by the followup routine */
	/* if q->rvar = NULL, perform post_rtn only */
	if (q->rvar) {
	    if (q->qual) qual = build_qual(q->qual, q->argc, Argv);
	    if (v && v->post_rtn) {
		sq = sq_create();
		status = do_retrieve(q, qual, sq_save_args, (char *)sq);
		if (status != MR_SUCCESS) {
		    sq_destroy(sq);
		    break;
		}
		status = (*v->post_rtn)(q, sq, v, action, actarg, cl);
	    } else {
		/* normal retrieve */
		status = do_retrieve(q, qual, action, actarg);
	    }
	    if (status != MR_SUCCESS) break;
	} else {
	    status = (*v->post_rtn)(q, Argv, cl, action, actarg);
	}

	break;

    case UPDATE:
	/* see if row already exists */
	if (v->field) {
	    status = validate_row(q, Argv, v);
	    if (status != MR_EXISTS) break;
	}

	/* build "where" clause and perform update */
	/* if q->rvar = NULL, perform post_rtn only */
	if (q->rvar) {
	    qual = build_qual(q->qual, q->argc, Argv);
	    incremental_before(q->rtable, qual, argv_ro);
	    status = do_update(q, &Argv[q->argc], qual, action, actarg);
	    incremental_after(q->rtable, qual, argv_ro);
	    if (status != MR_SUCCESS) break;
	    flush_name(argv_ro[0], q->rtable);
	    table = table_name[q->rtable];
	    if (strcmp(q->shortname, "sshi") && strcmp(q->shortname, "ssif")) {
		EXEC SQL UPDATE tblstats
                  SET updates = updates + 1, modtime = SYSDATE
		  WHERE table_name = :table;
	    }
	}

	/* execute followup routine (if any) */
	if (v->post_rtn) status = (*v->post_rtn)(q, Argv, cl);

	break;

    case APPEND:
	/* see if row already exists */
	if (v->field) {
	    status = validate_row(q, Argv, v);
	    if (status != MR_NO_MATCH) break;
	}

	/* perform the append */
	/* if q->rvar = NULL, perform post_rtn only */
	if (q->rvar) {
	    if (q->qual) qual = build_qual(q->qual, q->argc, Argv);
	    incremental_clear_before();
	    status = do_append(q, &Argv[q->argc], qual, action, actarg);
	    if (status != MR_SUCCESS) break;
	    if (v && v->object_id) {
		qual = realloc(qual, 128);
		sprintf(qual, "%s.%s = %s",q->rvar, v->object_id, 
			Argv[q->argc+q->vcnt]);
		incremental_after(q->rtable, qual, argv_ro);
	    } else
	      incremental_after(q->rtable, qual, argv_ro);

	    table = table_name[q->rtable];
	    EXEC SQL UPDATE tblstats
	      SET appends = appends + 1, modtime = SYSDATE
	      WHERE table_name = :table;
	}
	
	/* execute followup routine */
	if (v->post_rtn) status = (*v->post_rtn)(q, Argv, cl);
	break;

    case DELETE:
	/* see if row already exists */
	if (v->field) {
	    status = validate_row(q, Argv, v);
	    if (status != MR_EXISTS) break;
	}

	/* build "where" clause and perform delete */
	/* if q->rvar = NULL, perform post_rtn only */
	if (q->rvar) {
	    qual = build_qual(q->qual, q->argc, Argv);
	    table = table_name[q->rtable];
     	    incremental_before(q->rtable, qual, argv_ro);
	    status = do_delete(q, qual, action, actarg);
	    incremental_clear_after();
	    if (status != MR_SUCCESS) break;
	    flush_name(argv_ro[0], q->rtable);
	    EXEC SQL UPDATE tblstats
	      SET deletes = deletes + 1, modtime = SYSDATE
	      WHERE table_name = :table;
	}

	/* execute followup routine */
	if (v->post_rtn) status = (*v->post_rtn)(q, Argv, cl);
	break;

    }

out:
    if (status == MR_SUCCESS && dbms_errno != 0) {
	com_err(whoami, MR_INTERNAL, "Server didn't notice DBMS ERROR %d",
		       dbms_errno);
	status = mr_errcode;
    }

    if (q->type == RETRIEVE) {
        EXEC SQL COMMIT WORK;
    } else {
        if (status == MR_SUCCESS) {
        EXEC SQL COMMIT WORK;
	    if (journal) {
		char buf[1024];
		int i;
		extern time_t now;

		fprintf(journal, "%% %s %s %s",
			cl->clname, cl->entity, ctime(&now));
		fprintf(journal, "%s[%d] ", q->name, cl->args->mr_version_no);
		for (i = 0; i < argc; i++) {
		    if (i != 0) {
			putc(' ', journal);
		    }
		    requote(buf, argv_ro[i], sizeof(buf));
		    fputs(buf, journal);
		}
		putc('\n', journal);
		fflush(journal);
	    }
	    incremental_update();
	} else {
	    cache_abort();
            EXEC SQL ROLLBACK WORK;
	    incremental_flush();
	}
    }
    cache_commit(); /* commit following abort is safe */
    if (qual) free(qual);

    if (status != MR_SUCCESS && log_flags & LOG_RES)
	com_err(whoami, status, " (Query failed)");
    return(status);
}

char *build_qual(fmt_buf, argc, argv)
     char *fmt_buf, *argv[];
     int argc;
{
    char *res, *result_buf, *fmt, *arg, *like;

    result_buf = malloc(2*(strlen(fmt_buf) + argc*ARGLEN));

    res = result_buf;
    fmt = fmt_buf;

    /* Look through the format for LIKE expressions and arguments.
       Substitute in the arguments, and simplify the `LIKE's to `='s
       where possible. */

    while (*fmt) {
	like = strstr(fmt, "LIKE");
	arg = strchr(fmt, '%');

	if (!like && !arg) {
	    /* only plain text remains */
	    strcpy(res, fmt);
	    break;
	} else if (!like || arg < like) {
	    /* copy to arg, then substitute */
	    strncpy(res, fmt, arg - fmt - 1);
	    res += arg - fmt;
	    if(*++arg) {
		switch(*arg++) {                       
		    case '%':
			*res++ = '%';
			break;
		    case 's':
			if(*argv[0]) {
			    char *p = *argv;
			    while(*p) {
				if(*p == '\'') *res++ = '\'';
				*res++ = *p++;
			    }
			}
			argv++;
			break;
		    case 'd':
			res += sprintf(res, "%d", *(int *)*argv++);
			break;
		}
	    }
	    fmt = arg;
	    arg = strchr(fmt, '%');
	} else {
	    /* copy over up to the arg, then copy and convert the arg */
	    char *p;
	    int escape = 0;
	    
	    strncpy(res, fmt, arg - fmt - 1);
	    res += arg - fmt;
	    for (p = *argv++; *p; p++) {
		switch (*p) {
		    case '\'': *res++ = '\''; *res++ = '\''; break;
		    case '*': *res++ = '%'; break;
		    case '?': *res++ = '_'; break;
		    case '%':
		    case '_': *res++ = '*'; *res++ = *p; escape = 1; break;
		    default: *res++ = *p;
		}
	    }
	    if (escape) res += sprintf(res, " ESCAPE '*'");
	    
	    fmt += 2;
	    arg = strchr(fmt, '%');
	    like = strstr(fmt, "LIKE");
	}
    }

    result_buf = realloc(result_buf, strlen(result_buf) + 1);
    return result_buf;
}

/* Build argument vector, verify query and arguments */

int privileged;

int mr_verify_query(cl, q, argc, argv_ro)
     client *cl;
     struct query *q;
     int argc;
     char *argv_ro[];
{
    register int argreq;
    register int status;
    register struct validate *v = q->validate;
    register int i;
    register char *to,*fr,*stop;

    privileged = 0;

    /* check argument count */
    argreq = q->argc;
    if (q->type == UPDATE || q->type == APPEND) argreq += q->vcnt;
    if (argc != argreq) return(MR_ARGS);

    /* copy the arguments into a local argv that we can modify */
    for (i = 0; i < argc; i++) {
	for (to=Argv[i], fr=argv_ro[i], stop=to+ARGLEN; (*fr) && (to<stop);)
	  *to++ = *fr++;

	if (*fr) 
	  return(MR_ARG_TOO_LONG);
	*to='\0';

	if (*--to == '\\')
	  return(MR_BAD_CHAR);
    }

    /* check initial query access */
    status = check_query_access(q, Argv, cl);
    if (status != MR_SUCCESS && status != MR_PERM)
	return(status);
    if (status == MR_SUCCESS)
	privileged++;

    /* validate arguments */
    if (v && v->valobj) {
	status = validate_fields(q, Argv, v->valobj, v->objcnt);
	if (status != MR_SUCCESS) return(status);
    }

    /* perform special query access check */
    if (!privileged && v && v->acs_rtn) {
	status = (*v->acs_rtn)(q, Argv, cl);
	if (status != MR_SUCCESS && status != MR_PERM)
	    return(status);
	if (status == MR_SUCCESS)
	    return(MR_SUCCESS);
    }

    return(privileged ? MR_SUCCESS : MR_PERM);
}


/* This routine caches info from the database.  Each query acl is stored
 * in the query structure, and whether that acl contains everybody.
 */

int check_query_access(q, argv, cl)
     struct query *q;
     char *argv[];
     client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    char *name;
    int acl_id;
    static int def_uid;
    EXEC SQL END DECLARE SECTION; 

    /* initialize default uid */
    if (def_uid == 0) {
        EXEC SQL SELECT users_id INTO :def_uid FROM users WHERE login='default';
    }

    /* get query access control list */
    if (q->acl != 0)
      acl_id = q->acl;
    else {
	name = q->shortname;
	EXEC SQL SELECT list_id INTO :acl_id FROM capacls WHERE tag = :name;
        if (sqlca.sqlcode < 0) return(MR_DBMS_ERR);
        if (sqlca.sqlcode == SQL_NO_MATCH) return(MR_PERM);
	q->acl = acl_id;

	/* check for default access */
        EXEC SQL SELECT member_id INTO :acl_id FROM imembers
          WHERE list_id = :acl_id AND member_type = 'USER' 
	    AND member_id = :def_uid;
        if (sqlca.sqlerrd[2] == 0)
          q->everybody = 0;
        else
          q->everybody = 1;
    }

    if (q->everybody)
      return(MR_SUCCESS);

    if (find_member("LIST", acl_id, cl))
      return(MR_SUCCESS);
    else
      return(MR_PERM);
}


int find_member(list_type, list_id, cl)
     char *list_type;
     int list_id;
     client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int flag, users_id, client_id;
    EXEC SQL END DECLARE SECTION; 

    if (!strcmp(strtrim(list_type), "USER") &&
	list_id == cl->users_id)
	return(1);

    if (!strcmp(strtrim(list_type), "KERBEROS") &&
	list_id == -cl->client_id)
	return(1);

    /* see if client is a member of list */
    flag = 0;
    users_id = cl->users_id;
    client_id = -cl->client_id;
    EXEC SQL SELECT COUNT(member_id) INTO :flag FROM imembers
	WHERE list_id = :list_id
	AND ( ( member_type = 'USER' AND member_id = :users_id )
	      OR (member_type = 'KERBEROS' AND member_id = :client_id ) );
    if (sqlca.sqlcode == 0)
      return(flag);            
    return(0);
}


int do_retrieve(q, pqual, action, actarg)
     struct query *q;
     char *pqual, *actarg;
     int (*action)();
{
    char *stmt;
    int status;

    stmt = build_sql_stmt("SELECT",q->tlist,NULL,0,pqual,q->sort);
    status = do_for_all_rows(stmt_buf, q->vcnt, action, (int)actarg);
    free(stmt);
    return status;
}

char *build_sql_stmt(cmd, targetlist, argv, argc, qual, sort)
     char *cmd, *targetlist, *argv[], *qual, *sort;
     int argc;
{
    char *result_buf;
    int len;
    register char *res, *fmt;

    len = strlen(cmd) + strlen(targetlist) + argc*ARGLEN + 3;
    if (qual) len += strlen(qual) + 6;
    if (sort) len += strlen(sort) + 10;
    result_buf = malloc(len);

    sprintf(result_buf, "%s ", cmd);

    for(res=strchr(result_buf, '\0'), fmt=targetlist; *fmt; fmt++) {
	if(*fmt=='%') {
	    if(*++fmt) {
		switch(*fmt) {                       
		  case '%':
		    *res++ = *fmt;           
		    break;
		  case 's':
		    if(*argv[0]) {
		        char *p=*argv;
			while(*p) {
			    if(*p=='\'') *res++='\'';
			    *res++=*p++;
			}
		    }
		    argv++;
		    break;
		  case 'd':
		    res+=sprintf(res,"%d",*(int *)*argv++);
		    break;
		  default:
		    break;
		}
	    } else break;
	} else *res++ = *fmt;
    }
    *res='\0';

    if (qual)
	res += sprintf(res, " WHERE %s", qual);

    if(sort)
	res += sprintf(res, " ORDER BY %s", sort);

    result_buf = realloc(result_buf, strlen(result_buf));

    return result_buf;
}

int do_update(q, argv, qual, action, actarg)
     struct query *q;
     char *argv[], *qual, *actarg;
     int (*action)();
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *stmt;
    EXEC SQL END DECLARE SECTION;

    stmt = build_sql_stmt("UPDATE",q->tlist,argv,q->vcnt,qual,NULL);
    EXEC SQL EXECUTE IMMEDIATE :stmt;
    free(stmt);
    if (mr_errcode) return(mr_errcode);
    return(MR_SUCCESS);
}

int do_append(q, argv, pqual, action, actarg)
     struct query *q;
     char *argv[], *pqual, *actarg;
     int (*action)();
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *stmt;
    EXEC SQL END DECLARE SECTION;

    stmt = build_sql_stmt("INSERT",q->tlist,argv,q->vcnt,pqual,NULL);
    EXEC SQL EXECUTE IMMEDIATE :stmt;
    free(stmt);
    if (mr_errcode) return(mr_errcode);
    return(MR_SUCCESS);
}

int do_delete(q, qual, action, actarg)
     struct query *q;
     char *qual, *actarg;
     int (*action)();
{
    sprintf(stmt_buf,"DELETE FROM %s WHERE %s",table_name[q->rtable],qual);
    EXEC SQL EXECUTE IMMEDIATE :stmt_buf;
    if (mr_errcode) return(mr_errcode);
    return(MR_SUCCESS);
}


/**
 ** set_next_object_id - set next object id in values table
 **
 ** Inputs: object - object name in values table and in objects
 **	    table - name of table objects are found in
 **	    limit - should the ID be range limited
 **
 ** - called before an APPEND operation to set the next object id to
 **   be used for the new record to the next free value
 **
 **/

int set_next_object_id(object, table, limit)
EXEC SQL BEGIN DECLARE SECTION;
     char *object;
EXEC SQL END DECLARE SECTION;
     enum tables table;
     int limit;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int value;
    EXEC SQL END DECLARE SECTION;
    int starting_value;
    
    EXEC SQL SELECT value INTO :value FROM numvalues WHERE name = :object;
    if (sqlca.sqlerrd[2] != 1)
	return(MR_NO_ID);

    starting_value=value;
    while (1) { 
	if (limit && value > MAX_ID_VALUE) 
	    value = MIN_ID_VALUE;

	sprintf(stmt_buf,"SELECT %s FROM %s WHERE %s=%d",
		object,table_name[table],object,value);
	dosql(sqlbuffer);
	if (sqlca.sqlcode < 0) return(mr_errcode);
	if (sqlca.sqlcode == SQL_NO_MATCH) break;

	value++;
	if (limit && value == starting_value) {   
	    com_err(whoami,0,"All id values have been used");
	    return(MR_NO_ID);
	}
    }

    if (LOG_RES)
        com_err(whoami, 0, "setting ID %s to %d", object, value);
    EXEC SQL UPDATE numvalues SET value = :value WHERE name = :object;
    return(MR_SUCCESS);
}


/* Turn a kerberos name into the user's ID of the account that principal
 * owns.  Sets the kerberos ID and user ID.
 */

int set_krb_mapping(name, login, ok, kid, uid)
     char *name, *login;
     int ok, *kid, *uid;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int u_id, k_id;
    char *krbname;
    EXEC SQL END DECLARE SECTION; 

    krbname = name;
    *kid = 0;
    *uid = 0;

    EXEC SQL SELECT km.users_id, km.string_id INTO :u_id, :k_id
      FROM krbmap km, strings str
      WHERE km.string_id = str.string_id AND str.string = :krbname;
    EXEC SQL COMMIT WORK;

    if (dbms_errno) return(mr_errcode);
    
    if (sqlca.sqlerrd[2] == 1) {    /* rowcount */
	*kid = -k_id;
	*uid = u_id;
	return(MR_SUCCESS);
    }

    if (name_to_id(name, STRINGS_TABLE, &k_id) == MR_SUCCESS)
      *kid = -k_id;

    if (!ok) {             
	*uid = *kid;
	return(MR_SUCCESS);
    }

    if (name_to_id(login, USERS_TABLE, uid) != MR_SUCCESS)
      *uid = 0;

    if (*kid == 0)
      *kid = *uid;
    if (dbms_errno) return(mr_errcode);
    return(MR_SUCCESS);
}


/* For now this just checks the argc's.  It should also see that there
 * are no duplicate names.
 */

void sanity_check_queries(void)
{
    register int i;
    int maxv = 0, maxa = 0;
    extern int QueryCount2;
    extern struct query Queries2[];

#define MAX(x,y) ((x) > (y) ? (x) : (y))

    for (i = 0; i < QueryCount2; i++) {
	maxv = MAX(maxv, Queries2[i].vcnt);
	maxa = MAX(maxa, Queries2[i].argc);
    }
    if (MAX(maxv, maxa) > QMAXARGS) {
	com_err(whoami, 0, "A query has more args than QMAXARGS");
	exit(1);
    }
}


/* Generically do a SELECT, storing the results in the provided buffers */

void dosql(buffers)
     char *buffers[];
{
  int i, errcode=0, errlen;

  EXEC SQL PREPARE inc_stmt FROM :stmt_buf;
  if(sqlca.sqlcode) return;
  EXEC SQL DECLARE inc_crs CURSOR FOR inc_stmt;
  EXEC SQL OPEN inc_crs;
  mr_sqlda->N = QMAXARGS;
  EXEC SQL DESCRIBE SELECT LIST FOR inc_stmt INTO mr_sqlda;
  mr_sqlda->N = mr_sqlda->F;
  for(i=0; i<mr_sqlda->N; i++) {
    mr_sqlda->V[i]=buffers[i];
    mr_sqlda->T[i]=97;
    mr_sqlda->L[i]=ARGLEN;
  }
  EXEC SQL FETCH inc_crs USING DESCRIPTOR mr_sqlda;

  /* if we got an error from the FETCH, we have to preserve it or the
     close will reset it and the caller will think nothing happened */
  if(sqlca.sqlcode) {
    errcode=sqlca.sqlcode;
    errlen=sqlca.sqlerrm.sqlerrml;
  }

  EXEC SQL CLOSE inc_crs;
  if(errcode) {
    sqlca.sqlcode=errcode;
    sqlca.sqlerrm.sqlerrml=errlen;
  }
}

int do_for_all_rows(query, count, action, actarg)
EXEC SQL BEGIN DECLARE SECTION;
     char *query;
EXEC SQL END DECLARE SECTION;
     int count, (*action)(), actarg;
{
  int i, rowcount=0;

  EXEC SQL PREPARE stmt FROM :query;
  if(sqlca.sqlcode) return;
  EXEC SQL DECLARE curs CURSOR FOR stmt;
  EXEC SQL OPEN curs;
  mr_sqlda->N = count;
  EXEC SQL DESCRIBE SELECT LIST FOR stmt INTO mr_sqlda;
  mr_sqlda->N = mr_sqlda->F;
  for(i=0; i<mr_sqlda->N; i++) {
    mr_sqlda->V[i]=sqlbuffer[i];
    mr_sqlda->T[i]=97;
    mr_sqlda->L[i]=ARGLEN;
  }

  while(1) {
    EXEC SQL FETCH curs USING DESCRIPTOR mr_sqlda;
    if(sqlca.sqlcode != 0) break;
    (*action)(count, sqlbuffer, actarg);
    rowcount++;
  }
  EXEC SQL CLOSE curs;
  
  if (mr_errcode) return(mr_errcode);
  return ((rowcount == 0) ? MR_NO_MATCH : MR_SUCCESS);
}


/* eof:qrtn.dc */
