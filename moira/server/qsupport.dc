/*
 *	$Source: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/server/qsupport.dc,v $
 *	$Author: kostas $
 *	$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/server/qsupport.dc,v 1.7 1990-10-01 13:37:40 kostas Exp $
 *
 *	Copyright (C) 1987 by the Massachusetts Institute of Technology
 *	For copying and distribution information, please see the file
 *	<mit-copyright.h>.
 *
 */

#ifndef lint
static char *rcsid_qsupport_qc = "$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/server/qsupport.dc,v 1.7 1990-10-01 13:37:40 kostas Exp $";
#endif lint

#include <mit-copyright.h>
#include "query.h"
#include "mr_server.h"
#include <ctype.h>
EXEC SQL INCLUDE SQLCA;  /* SQL Communications Area */
EXEC SQL INCLUDE SQLDA;  /* SQL Descriptor Area */

extern char *whoami, *strsave();
extern int ingres_errno, mr_errcode;


/* Specialized Access Routines */

/* access_user - verify that client name equals specified login name
 *
 *  - since field validation routines are called first, a users_id is
 *    now in argv[0] instead of the login name.
 */

access_user(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    if (cl->users_id != *(int *)argv[0])
	return(MR_PERM);
    else
	return(MR_SUCCESS);
}

    

/* access_login - verify that client name equals specified login name
 *
 *   argv[0...n] contain search info.  q->
 */

access_login(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;

{
    EXEC SQL BEGIN DECLARE SECTION;
    int id;
    char qual[256];
    char stmt_1_str[256];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL DECLARE stmt_1 STATEMENT;

    build_qual(q->qual, q->argc, argv, qual);

    sprintf(stmt_1_str, 
            "SELECT users_id INTO %s FROM users WHERE %s",
            id, qual );

    EXEC SQL PREPARE stmt_1 FROM :stmt_1_str;
    EXEC SQL DESCRIBE stmt_1 INTO SQLDA;
    EXEC SQL EXECUTE stmt_1;
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1 || id != cl->users_id)
        return(MR_PERM);
    else
        return(MR_SUCCESS);

}

    

/* access_list - check access for most list operations
 *
 * Inputs: argv[0] - list_id
 *	    q - query name
 *	    argv[2] - member ID (only for queries "amtl" and  "dmfl")
 *	    argv[7] - group IID (only for query "ulis")
 *          cl - client name
 *
 * - check that client is a member of the access control list
 * - OR, if the query is add_member_to_list or delete_member_from_list
 *	and the list is public, allow access if client = member
 */ 

access_list(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int list_id, acl_id, flags, rowcount, gid;
    char acl_type[9];
    EXEC SQL END DECLARE SECTION;
    char *client_type;
    int client_id, status;

    list_id = *(int *)argv[0];
    EXEC SQL SELECT acl_id, acl_type, gid, public
             INTO :acl_id, :acl_type, :gid, :flags
             FROM list
             WHERE list_id = :list_id;
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_INTERNAL);

    /* parse client structure */
    if ((status = get_client(cl, &client_type, &client_id)) != MR_SUCCESS)
	return(status);

    /* if amtl or dmfl and list is public allow client to add or delete self */
    if (((!strcmp("amtl", q->shortname) && flags) ||
	 (!strcmp("dmfl", q->shortname))) &&
	(!strcmp("USER", argv[1]))) {
	if (*(int *)argv[2] == client_id) return(MR_SUCCESS);
    /* if update_list, don't allow them to change the GID */
    } else if (!strcmp("ulis", q->shortname)) {
	if ((!strcmp(argv[7], UNIQUE_GID) && (gid != -1)) ||
	    (strcmp(argv[7], UNIQUE_GID) && (gid != atoi(argv[7]))))
	  return(MR_PERM);
    }

    /* check for client in access control list */
    status = find_member(acl_type, acl_id, client_type, client_id, 0);
    if (!status) return(MR_PERM);

    return(MR_SUCCESS);
}


/* access_visible_list - allow access to list only if it is not hidden,
 *	or if the client is on the ACL
 *
 * Inputs: argv[0] - list_id
 *         cl - client identifier
 */ 

access_visible_list(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int list_id, acl_id, flags, rowcount;
    char acl_type[9];
    EXEC SQL END DECLARE SECTION;
    char *client_type;
    int client_id, status;

    list_id = *(int *)argv[0];
    EXEC SQL SELECT hidden, acl_id, acl_type
             INTO :flags, :acl_id, :acl_type
             FROM list
             WHERE list_id = :list_id;
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_INTERNAL);
    if (!flags)
	return(MR_SUCCESS);


    /* parse client structure */
    if ((status = get_client(cl, &client_type, &client_id)) != MR_SUCCESS)
	return(status);

    /* check for client in access control list */
    status = find_member(acl_type, acl_id, client_type, client_id, 0);
    if (!status)
	return(MR_PERM);

    return(MR_SUCCESS);
}


/* access_vis_list_by_name - allow access to list only if it is not hidden,
 *	or if the client is on the ACL
 *
 * Inputs: argv[0] - list name
 *         cl - client identifier
 */ 

access_vis_list_by_name(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int acl_id, flags, rowcount;
    char acl_type[9], *listname;
    EXEC SQL END DECLARE SECTION;
    char *client_type;
    int client_id, status;

    listname = argv[0];
    EXEC SQL SELECT hidden, acl_id, acl_type
             INTO :flags, :acl_id, :acl_type
             FROM list
             WHERE name = :listname;
    if (sqlca.sqlerrd[2] > 1)  return(MR_WILDCARD);
    if (sqlca.sqlcode == 100) return(MR_NO_MATCH);
    if (!flags)
	return(MR_SUCCESS);

    /* parse client structure */
    if ((status = get_client(cl, &client_type, &client_id)) != MR_SUCCESS)
	return(status);

    /* check for client in access control list */
    status = find_member(acl_type, acl_id, client_type, client_id, 0);
    if (!status)
	return(MR_PERM);

    return(MR_SUCCESS);
}


/* access_member - allow user to access member of type "USER" and name matches
 * username, or to access member of type "LIST" and list is one that user is
 * on the acl of, or the list is visible.
 */

access_member(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    if (!strcmp(argv[0], "LIST") || !strcmp(argv[0], "RLIST"))
      return(access_visible_list(q, &argv[1], cl));

    if (!strcmp(argv[0], "USER") || !strcmp(argv[0], "RUSER")) {
	if (cl->users_id == *(int *)argv[1])
	  return(MR_SUCCESS);
    }

    return(MR_PERM);
}


/* access_qgli - special access routine for Qualified_get_lists.  Allows
 * access iff argv[0] == "TRUE" and argv[2] == "FALSE".
 */

access_qgli(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    if (!strcmp(argv[0], "TRUE") && !strcmp(argv[2], "FALSE"))
      return(MR_SUCCESS);
    return(MR_PERM);
}


/* access_service - allow access if user is on ACL of service.  Don't
 * allow access if a wildcard is used.
 */

access_service(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int acl_id, rowcount;
    char *name, acl_type[9];
    EXEC SQL END DECLARE SECTION;
    int client_id, status;
    char *client_type;

    name = argv[0];
    uppercase(name);
    EXEC SQL SELECT acl_id, acl_type
             INTO :acl_id, :acl_type
             FROM servers
             WHERE name = :name;
    if (sqlca.sqlerrd[2] > 1) return(MR_PERM);
    /* parse client structure */
    if ((status = get_client(cl, &client_type, &client_id)) != MR_SUCCESS)
	return(status);

    /* check for client in access control list */
    status = find_member(acl_type, acl_id, client_type, client_id, 0);
    if (!status) return(MR_PERM);

    return(MR_SUCCESS);
}



/* access_filesys - verify that client is owner or on owners list of filesystem
 *	named by argv[0]
 */

access_filesys(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int users_id, list_id;
    char *name;
    EXEC SQL END DECLARE SECTION;
    int status, client_id;
    char *client_type;

    name = argv[0];
    EXEC SQL SELECT owner, owners 
             INTO :users_id, :list_id
             FROM filesys
             WHERE label = :name;
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_PERM);

    if (users_id == cl->users_id)
      return(MR_SUCCESS);
    if ((status = get_client(cl, &client_type, &client_id)) != MR_SUCCESS)
      return(status);
    status = find_member("LIST", list_id, client_type, client_id, 0);
    if (status)
      return(MR_SUCCESS);
    else
      return(MR_PERM);
}

    

/* Setup Routines */

/* Setup routine for add_user
 *
 * Inputs: argv[0] - login
 *         argv[1] - uid
 *
 * Description:
 *
 * - if argv[1] == UNIQUE_UID then set argv[1] = next(uid)
 * - if argv[0] == UNIQUE_LOGIN then set argv[0] = "#<uid>"
 */

setup_ausr(q, argv, cl)
    struct query *q;
    register char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int nuid;
    char *mit_id;
    EXEC SQL END DECLARE SECTION;

#ifdef notdef
    /* this is currently disabled because we need an index on ID's
     * before it can run in finite time.
     */
    mit_id = argv[U_MITID];
##  retrieve (rowcount = any(u.#mit_id where u.#mit_id = mit_id))
    if (ingres_errno) return(mr_errcode);
    if (rowcount) return(MR_EXISTS);
#endif notdef

    if (!strcmp(argv[1], UNIQUE_UID) || atoi(argv[1]) == -1) {
	if (set_next_object_id("uid", "users"))
	  return(MR_INGRES_ERR);
        EXEC SQL SELECT value  
             INTO :nuid
             FROM values_tbl
             WHERE name = "uid";
        if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
	  return(MR_INTERNAL);
	sprintf(argv[1], "%d", nuid);
    }

    if (!strcmp(argv[0], UNIQUE_LOGIN) || atoi(argv[1]) == -1) {
	sprintf(argv[0], "#%s", argv[1]);
    }

    return(MR_SUCCESS);
d#}


/* setup_dusr - verify that the user is no longer being referenced 
 * and may safely be deleted.
 */

int setup_dusr(q, argv)
    struct query *q;
    char **argv;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int flag, id;
    EXEC SQL END DECLARE SECTION;

    id = *(int *)argv[0];

    /* For now, only allow users to be deleted if their status is 0 */
##  repeat retrieve (flag = u.status) where u.users_id = @id
    if (flag != 0 && flag != 4)
      return(MR_IN_USE);

##  repeat delete quota where quota.entity_id = @id and quota.type = "USER"
##  repeat delete krbmap where krbmap.users_id = @id
##  repeat retrieve (flag = any(imembers.member_id where imembers.member_id=@id
##			 and imembers.member_type = "USER"))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(filesys.label where filesys.owner=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(list.name where list.acl_id=@id and
##			list.acl_type = "USER"))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(servers.name where servers.acl_id=@id and
##			servers.acl_type = "USER"))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag=any(hostaccess.acl_id where hostaccess.acl_id=@id and
##			hostaccess.acl_type = "USER"))
    if (flag)
	return(MR_IN_USE);
    if (ingres_errno)
	return(mr_errcode);
    return(MR_SUCCESS);
}


/* setup_spop: verify that there is already a valid POP machine_id in the
 * pop_id field.  Also take care of keeping track of the post office usage.
 */
int setup_spop(q, argv)
struct query *q;
char **argv;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id, mid, flag;
    char type[9];
    EXEC SQL END DECLARE SECTION;

    id = *(int *)argv[0];
##  repeat retrieve (type = u.potype, mid = u.pop_id,
##		     flag = any(machine.name where machine.mach_id = u.pop_id 
##				     and u.pop_id != 0 and u.users_id = @id))
##	where u.users_id = @id
    if (!flag)
      return(MR_MACHINE);
    if (strcmp(strtrim(type), "POP"))
      set_pop_usage(mid, 1);
    return(MR_SUCCESS);
}


/* setup_dpob:  Take care of keeping track of the post office usage.
 */
int setup_dpob(q, argv)
struct query *q;
char **argv;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id, user;
    char type[9];
    EXEC SQL END DECLARE SECTION;

    user = *(int *)argv[0];
    EXEC SQL SELECT potype, pop_id
             INTO :type, :id
             FROM users
             WHERE users_id = :user;
    if (ingres_errno) return(mr_errcode);

    if (!strcmp(strtrim(type), "POP"))
      set_pop_usage(id, -1);
    return(MR_SUCCESS);
}


/* setup_dmac - verify that the machine is no longer being referenced 
 * and may safely be deleted.
 */

int setup_dmac(q, argv)
    struct query *q;
    char **argv;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int flag, id;
    EXEC SQL END DECLARE SECTION;

    id = *(int *)argv[0];
##  repeat retrieve (flag = any(users.login where users.potype = "POP" 
##						  and users.pop_id=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(serverhosts.mach_id
##				 where serverhosts.mach_id=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(nfsphys.mach_id where nfsphys.mach_id=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(hostaccess.mach_id where hostaccess.mach_id=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(printcap.mach_id where printcap.mach_id=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(printcap.quotaserver where printcap.quotaserver=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(palladium.mach_id where palladium.mach_id=@id))
    if (flag)
	return(MR_IN_USE);

##  repeat delete mcmap where mcmap.mach_id = @id
    if (ingres_errno) return(mr_errcode);
    return(MR_SUCCESS);
}


/* setup_dclu - verify that the cluster is no longer being referenced 
 * and may safely be deleted.
 */

int setup_dclu(q, argv)
    struct query *q;
    char **argv;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int flag, id;
    EXEC SQL END DECLARE SECTION;

    id = *(int *)argv[0];
##  repeat retrieve (flag = any(mcmap.mach_id where mcmap.clu_id=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(svc.clu_id where svc.clu_id=@id))
    if (flag)
	return(MR_IN_USE);
    if (ingres_errno)
	return(mr_errcode);
    return(MR_SUCCESS);
}


/* setup_alis - if argv[5] is non-zero and argv[6] is UNIQUE_ID, then allocate
 * a new gid and put it in argv[6].  Otherwise if argv[6] is UNIQUE_ID but
 * argv[5] is not, then remember that UNIQUE_ID is being stored by putting
 * a -1 there.  Remember that this is also used for ulis, with the indexes
 * at 6 & 7.
 */

int setup_alis(q, argv)
struct query *q;
char **argv;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int ngid;
    EXEC SQL END DECLARE SECTION;
    char *malloc();
    int idx;

    if (!strcmp(q->shortname, "alis"))
      idx = 6;
    else if (!strcmp(q->shortname, "ulis"))
      idx = 7;

    if (!strcmp(argv[idx], UNIQUE_GID) || atoi(argv[idx]) == -1) {
	if (atoi(argv[idx - 1])) {
	    if (set_next_object_id("gid", "list"))
	      return(MR_INGRES_ERR);
            EXEC SQL SELECT value 
                     INTO :ngid
                     FROM values_tbl
                     WHERE name = "gid";
	    if (ingres_errno) return(mr_errcode);
	    sprintf(argv[idx], "%d", ngid);
	} else {
	    strcpy(argv[idx], "-1");
	}
    }

    return(MR_SUCCESS);
}


/* setup_dlist - verify that the list is no longer being referenced 
 * and may safely be deleted.
 */

int setup_dlis(q, argv)
    struct query *q;
    char **argv;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int flag, id;
    EXEC SQL END DECLARE SECTION;

    id = *(int *)argv[0];
##  repeat retrieve (flag = any(imembers.member_id where imembers.member_id=@id
##			 and imembers.member_type = "LIST"))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(imembers.member_id where imembers.list_id=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(filesys.label where filesys.owners=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(capacls.tag where capacls.list_id=@id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(list.name where list.acl_id=@id and
##			list.acl_type = "LIST" and list.list_id != @id))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(servers.name where servers.acl_id=@id and
##			servers.acl_type = "LIST"))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(quota.entity_id where quota.entity_id=@id and
##			quota.type = "GROUP"))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag=any(hostaccess.acl_id where hostaccess.acl_id=@id and
##			hostaccess.acl_type = "LIST"))
    if (flag)
	return(MR_IN_USE);
##  repeat retrieve (flag = any(zephyr.class
##		where zephyr.xmt_type = "LIST" and zephyr.xmt_id = @id or
##		      zephyr.sub_type = "LIST" and zephyr.sub_id = @id or
##		      zephyr.iws_type = "LIST" and zephyr.iws_id = @id or
##		      zephyr.iui_type = "LIST" and zephyr.iui_id = @id))
    if (flag)
        return(MR_IN_USE);
    if (ingres_errno)
	return(mr_errcode);
    return(MR_SUCCESS);
}


/* setup_dsin - verify that the service is no longer being referenced 
 * and may safely be deleted.
 */

int setup_dsin(q, argv)
    struct query *q;
    char **argv;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int flag;
    char *name;
    EXEC SQL END DECLARE SECTION;

    name = argv[0];
##  repeat retrieve (flag = any(serverhosts.service 
##				where serverhosts.service=uppercase(@name)))
    if (flag)
	return(MR_IN_USE);
    EXEC SQL SELECT inprogress  
             INTO :flag
             FROM servers
             WHERE name = :name;
    if (flag)
	return(MR_IN_USE);
    if (ingres_errno)
	return(mr_errcode);
    return(MR_SUCCESS);
}


/* setup_dshi - verify that the service-host is no longer being referenced 
 * and may safely be deleted.
 */

int setup_dshi(q, argv)
    struct query *q;
    char **argv;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int flag, id;
    char *name;
    EXEC SQL END DECLARE SECTION;

    name = argv[0];
    id = *(int *)argv[1];
    uppercase(name);
    EXEC SQL SELECT inprogress  
             INTO :flag
             FROM serverhosts
             WHERE service = :name AND mach_id = :id;
    if (flag)
	return(MR_IN_USE);
    if (ingres_errno)
	return(mr_errcode);
    return(MR_SUCCESS);
}


/**
 ** setup_add_filesys - verify existance of referenced file systems
 **
 ** Inputs:     Add
 **   argv[1] - type
 **   argv[2] - mach_id
 **   argv[3] - name
 **   argv[5] - access
 **
 ** Description:
 **   - for type = RVD:
 **	   * allow anything
 **   - for type = NFS:
 **        * extract directory prefix from name
 **        * verify mach_id/dir in nfsphys
 **        * verify access in {r, w, R, W}
 **
 **  Side effect: sets variable var_phys_id to the ID of the physical
 **	filesystem (nfsphys_id for NFS, 0 for RVD)
 **
 ** Errors:
 **   MR_NFS - specified directory not exported
 **   MR_FILESYS_ACCESS - invalid filesys access
 **
 **/

##static int var_phys_id;

setup_afil(q, argv)
    struct query *q;
    char *argv[];
{
    char *type, *name;
    int mach_id;
    EXEC SQL BEGIN DECLARE SECTION;
    int ok;
    char ftype[32], *access;
    EXEC SQL END DECLARE SECTION;

    type = argv[1];
    mach_id = *(int *)argv[2];
    name = argv[3];
    access = argv[5];
    var_phys_id = 0;

    sprintf(ftype, "fs_access_%s", type);
##  retrieve (ok = any(alias.trans where alias.name = ftype and
##			     alias.type = "TYPE" and alias.trans = access))
    if (ingres_errno) return(mr_errcode);
    if (ok == 0) return(MR_FILESYS_ACCESS);

    if (!strcmp(type, "NFS"))
	return (check_nfs(mach_id, name, access));
    else
	return(MR_SUCCESS);
}


/* Verify the arguments, depending on the FStype.  Also, if this is an
 * NFS filesystem, then update any quotas for that filesystem to reflect
 * the new phys_id.
 */

setup_ufil(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    int mach_id, status;
    char *type, *name;  
    EXEC SQL BEGIN DECLARE SECTION;
    int fid, total, who;
    char *entity, ftype[32], *access;
    EXEC SQL END DECLARE SECTION;

    type = argv[2];
    mach_id = *(int *)argv[3];
    name = argv[4];
    access = argv[6];
    var_phys_id = 0;
    fid = *(int *)argv[0];
    who = cl->client_id;
    entity = cl->entity;

    sprintf(ftype, "fs_access_%s", type);
##  retrieve (total = any(alias.trans where alias.name = ftype and
##			     alias.type = "TYPE" and alias.trans = access))
    if (ingres_errno) return(mr_errcode);
    if (total == 0) return(MR_FILESYS_ACCESS);

    if (!strcmp(type, "NFS")) {
	status = check_nfs(mach_id, name, access);
##	replace quota (phys_id = var_phys_id) where quota.filsys_id = fid
	if (ingres_errno) return(mr_errcode);
	return(status);
    } else if (!strcmp(type, "AFS")) {
	total = 0;
##	retrieve (total = sum(quota.quota where quota.filsys_id = fid
##			      and quota.phys_id != 0))
	if (ingres_errno) return(mr_errcode);
	if (total != 0) {
##	    append quota (quota = total, filsys_id = fid,
##			     phys_id = 0, entity_id = 0, type = "ANY",
##			     modtime = "now", modby = who, modwith = entity)
	    if (ingres_errno) return(mr_errcode);
	}
    } else {
##	replace quota (phys_id = 0) where quota.filsys_id = fid
	if (ingres_errno) return(mr_errcode);
    }
    return(MR_SUCCESS);
}


/* Find the NFS physical partition that the named directory is on.
 * This is done by comparing the dir against the mount point of the
 * partition.  To make sure we get the correct match when there is 
 * more than one, we sort the query in reverse order by dir name.
 */

##check_nfs(mach_id, name, access)
    EXEC SQL BEGIN DECLARE SECTION;
    int mach_id;
    EXEC SQL END DECLARE SECTION;
    char *name;
    char *access;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dir[81];
    EXEC SQL END DECLARE SECTION;
    char caccess;
    register int status;
    register char *cp1;
    register char *cp2;

    status = MR_NFS;
##  range of np is nfsphys
##  repeat retrieve (var_phys_id = np.#nfsphys_id, dir = trim(np.#dir))
##	where np.#mach_id = @mach_id sort by #dir:d {
	 cp1 = name;
	 cp2 = dir;
	 while (*cp2) {
	     if (*cp1++ != *cp2) break;
	     cp2++;
	 }
	 if (*cp2 == 0) {
	     status = MR_SUCCESS;
##           endretrieve
	 }
##  }
    if (ingres_errno)
	return(mr_errcode);
    return(status);
}


/* setup_dfil: free any quota records and fsgroup info associated with
 * a filesystem when it is deleted.  Also adjust the allocation numbers.
 */

setup_dfil(q, argv, cl)
    struct query  *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id;
    EXEC SQL END DECLARE SECTION;

    id = *(int *)argv[0];
##  range of q is quota
##  range of n is nfsphys
##  repeat replace n (allocated=n.allocated-sum(q.quota where q.filsys_id=@id))
##	where n.nfsphys_id = filesys.phys_id and filesys.filsys_id = @id

##  repeat delete q where q.filsys_id = @id
##  repeat delete fsgroup where fsgroup.filsys_id = @id
##  repeat delete fsgroup where fsgroup.group_id = @id
    if (ingres_errno) return(mr_errcode);
    return(MR_SUCCESS);
}


/* setup_dnfp: check to see that the nfs physical partition does not have
 * any filesystems assigned to it before allowing it to be deleted.
 */

setup_dnfp(q, argv, cl)
    struct query  *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id, exist;
    char *dir;
    EXEC SQL END DECLARE SECTION;

    id = *(int *)argv[0];
    dir = argv[1];
##  repeat retrieve (exist = any(filesys.label where filesys.mach_id = @id
##				  and filesys.phys_id = nfsphys.nfsphys_id and
##				  nfsphys.mach_id = @id and nfsphys.#dir = @dir))
    if (exists)
      return(MR_IN_USE);
    if (ingres_errno)
      return(mr_errcode);
    return(MR_SUCCESS);
}


/* setup_dqot: Remove allocation from nfsphys before deleting quota.
 *   argv[0] = filsys_id
 *   argv[1] = type if "update_quota" or "delete_quota"
 *   argv[2 or 1] = users_id or list_id
 */

setup_dqot(q, argv, cl)
    struct query  *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int quota, fs, id;
    char *qtype;
    EXEC SQL END DECLARE SECTION;

    fs = *(int *)argv[0];
    if (!strcmp(q->name, "update_quota") || !strcmp(q->name, "delete_quota")) {
	qtype = argv[1];
	id = *(int *)argv[2];
    } else {
	qtype = "USER";
	id = *(int *)argv[1];
    }
    EXEC SQL SELECT quota_value
             INTO :quota
             FROM quota
             WHERE type = :qtype AND entity_id = :id AND filsys_id = :fs;
##  repeat replace nfsphys (allocated = nfsphys.allocated - @quota)
##	where nfsphys.nfsphys_id = filesys.#phys_id and filesys.filsys_id = @fs
    if (ingres_errno) return(mr_errcode);
    return(MR_SUCCESS);
}


/* setup_sshi: don't exclusive lock the machine table during
 * set_server_host_internal.
 */

setup_sshi(q, argv, cl)
    struct query  *q;
    char **argv;
    client *cl;
##{
##  set lockmode session where readlock = system
##}


/* setup add_kerberos_user_mapping: add the string to the string 
 * table if necessary.
 */

setup_akum(q, argv, cl)
struct query *q;
char **argv;
client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id, rowcount;
    char *name;
    EXEC SQL END DECLARE SECTION;

    name = argv[1];
    if (name_to_id(name, "STRING", &id) != MR_SUCCESS) {
	if (q->type != APPEND) return(MR_STRING);
    EXEC SQL SELECT value
             INTO :id
             FROM values_tbl
             WHERE name = "strings_id";
	id++;
##	replace v (value = id) where v.#name = "strings_id"
##	append to strings (string_id = id, string = name)
	cache_entry(name, "STRING", id);
    }
    if (ingres_errno) return(mr_errcode);
    *(int *)argv[1] = id;
    return(MR_SUCCESS);
}



/* FOLLOWUP ROUTINES */

/* generic set_modtime routine.  This takes the table name from the query,
 * and will update the modtime, modby, and modwho fields in the entry in
 * the table whose name field matches argv[0].
 */

set_modtime(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *name, *entity, *tbl;
    int who;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;
    tbl = q->rtable;
    name = argv[0];

##  replace tbl (modtime = "now", modby = who, modwith = entity)
##	 where tbl.#name = name
    return(MR_SUCCESS);
}

/* generic set_modtime_by_id routine.  This takes the table name from
 * the query, and the id name from the validate record,
 * and will update the modtime, modby, and modwho fields in the entry in
 * the table whose id matches argv[0].
 */

set_modtime_by_id(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *entity, *tbl, *id_name;
    int who, id;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;
    tbl = q->rtable;
    id_name = q->validate->object_id;

    id = *(int *)argv[0];
##  replace tbl (modtime = "now", modby = who, modwith = entity)
##	 where tbl.id_name = id
    return(MR_SUCCESS);
}


/* Sets the finger modtime on a user record.  The users_id will be in argv[0].
 */

set_finger_modtime(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int users_id, who;
    char *entity;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;
    users_id = *(int *)argv[0];

##  repeat replace u (fmodtime = "now", fmodby = @who, fmodwith = @entity)
##	 where u.#users_id = @users_id
    return(MR_SUCCESS);
}


/* Sets the pobox modtime on a user record.  The users_id will be in argv[0].
 */

set_pobox_modtime(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int users_id, who;
    char *entity;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;
    users_id = *(int *)argv[0];

##  repeat replace users (pmodtime = "now", pmodby = @who, pmodwith = @entity)
##	 where users.#users_id = @users_id
    return(MR_SUCCESS);
}


/* Like set_modtime, but uppercases the name first.
 */

set_uppercase_modtime(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *name, *entity, *tbl;
    int who;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;
    tbl = q->rtable;
    name = argv[0];

##  replace tbl (modtime = "now", modby = who, modwith = entity)
##	 where tbl.#name = uppercase(name)
    return(MR_SUCCESS);
}


/* Sets the modtime on the machine whose mach_id is in argv[0].  This routine
 * is necessary for add_machine_to_cluster becuase the table that query
 * operates on is "mcm", not "machine".
 */

set_mach_modtime_by_id(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *entity;
    int who, id;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;

    id = *(int *)argv[0];
##  repeat replace machine (modtime = "now", modby = @who, modwith = @entity)
##	 where machine.mach_id = @id
    return(MR_SUCCESS);
}


/* Sets the modtime on the cluster whose mach_id is in argv[0].  This routine
 * is necessary for add_cluster_data and delete_cluster_data becuase the
 * table that query operates on is "svc", not "cluster".
 */

set_cluster_modtime_by_id(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *entity;
    int who, id;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;

    id = *(int *)argv[0];
##  repeat replace cluster (modtime = "now", modby = @who, modwith = @entity)
##	 where cluster.clu_id = @id
    return(MR_SUCCESS);
}


/* sets the modtime on the serverhost where the service name is in argv[0]
 * and the mach_id is in argv[1].
 */

set_serverhost_modtime(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *entity, *serv;
    int who, id;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;

    serv = argv[0];
    id = *(int *)argv[1];
##  repeat replace sh (modtime = "now", modby = @who, modwith = @entity)
##	 where sh.service = uppercase(@serv) and sh.mach_id = @id
    return(MR_SUCCESS);
}


/* sets the modtime on the nfsphys where the mach_id is in argv[0] and the
 * directory name is in argv[1].
 */

set_nfsphys_modtime(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *entity, *dir;
    int who, id;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;

    id = *(int *)argv[0];
    dir = argv[1];
##  repeat replace np (modtime = "now", modby = @who, modwith = @entity)
##	 where np.#dir = @dir and np.mach_id = @id
    return(MR_SUCCESS);
}


/* sets the modtime on a filesystem, where argv[0] contains the filesys
 * label.
 */

set_filesys_modtime(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *label, *entity;
    int who;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;

    label = argv[0];
    if (!strcmp(q->shortname, "ufil"))
      label = argv[1];

##  repeat replace fs (modtime = "now", modby = @who, modwith = @entity,
##		       #phys_id = @var_phys_id)  where fs.#label = @label
    return(MR_SUCCESS);
}


/* sets the modtime on a zephyr class, where argv[0] contains the class
 * name.
 */

set_zephyr_modtime(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *class, *entity;
    int who;
    EXEC SQL END DECLARE SECTION;

    entity = cl->entity;
    who = cl->client_id;

    class = argv[0];

##  repeat replace z (modtime = "now", modby = @who, modwith = @entity)
##		       where z.#class = @class
    return(MR_SUCCESS);
}


/* fixes the modby field.  This will be the second to last thing in the
 * argv, the argv length is determined from the query structure.  It is
 * passed as a pointer to an integer.  This will either turn it into a
 * username, or # + the users_id.
 */
followup_fix_modby(q, sq, v, action, actarg, cl)
    struct query *q;
    register struct save_queue *sq;
    struct validate *v;
    register int (*action)();
    register int actarg;
    client *cl;
{
    register int i, j;
    char **argv, *malloc();
    int id, status;

    i = q->vcnt - 2;
    while (sq_get_data(sq, &argv)) {
	id = atoi(argv[i]);
	if (id > 0)
	  status = id_to_name(id, "USER", &argv[i]);
	else
	  status = id_to_name(-id, "STRING", &argv[i]);
	if (status && status != MR_NO_MATCH)
	  return(status);
	(*action)(q->vcnt, argv, actarg);
	for (j = 0; j < q->vcnt; j++)
	  free(argv[j]);
	free(argv);
    }
    sq_destroy(sq);
    return(MR_SUCCESS);
}


/**
 ** followup_ausr - add finger and pobox entries, set_user_modtime
 **
 ** Inputs:
 **	argv[0] - login (add_user)
 **	argv[3] - last name
 **	argv[4] - first name
 **	argv[5] - middle name
 **
 **/

followup_ausr(q, argv, cl)
    struct query *q;
    char *argv[];
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int who;
    char *login, *entity;
    char fullname[129];
    EXEC SQL END DECLARE SECTION;

    login = argv[0];
    who = cl->client_id;
    entity = cl->entity;

    /* build fullname */
    if (strlen(argv[4]) && strlen(argv[5]))
	sprintf(fullname, "%s %s %s", argv[4], argv[5], argv[3]);
    else if (strlen(argv[4]))
	sprintf(fullname, "%s %s", argv[4], argv[3]);
    else
	sprintf(fullname, "%s", argv[3]);

    /* create finger entry, pobox & set modtime on user */
##  repeat replace u (modtime = "now", modby=@who, modwith=@entity,
##	     #fullname=@fullname, mit_affil = u.mit_year,
##	     fmodtime="now", fmodby=@who, fmodwith=@entity,
##	     potype="NONE", pmodtime="now", pmodby=@who, pmodwith=@entity)
##	where u.#login = @login

    return(MR_SUCCESS);
}


/* followup_gpob: fixes argv[2] based on the IDs currently there and the
 * type in argv[1].  Then completes the upcall to the user.
 *
 * argv[2] is of the form "123:234" where the first integer is the machine
 * ID if it is a pop box, and the second is the string ID if it is an SMTP
 * box.  argv[1] should be "POP", "SMTP", or "NONE".  Boxes of type NONE
 * are skipped.
 */

followup_gpob(q, sq, v, action, actarg, cl)
    register struct query *q;
    register struct save_queue *sq;
    register struct validate *v;
    register int (*action)();
    int actarg;
    client *cl;
{
    char **argv, *index();
    char *ptype, *p;
    int mid, sid, status;

    /* for each row */
    while (sq_get_data(sq, &argv)) {
	mr_trim_args(2, argv);
	ptype = argv[1];
	p = index(argv[2], ':');
	*p++ = 0;
	mid = atoi(argv[2]);
	sid = atoi(p);

	if (!strcmp(ptype, "POP")) {
	    status = id_to_name(mid, "MACHINE", &argv[2]);
	    if (status == MR_NO_MATCH)
	      return(MR_MACHINE);
	} else if (!strcmp(ptype, "SMTP")) {
	    status = id_to_name(sid, "STRING", &argv[2]);
	    if (status == MR_NO_MATCH)
	      return(MR_STRING);
	} else /* ptype == "NONE" */ {
	    goto skip;
	}
	if (status) return(status);

	if (!strcmp(q->shortname, "gpob")) {
	    sid = atoi(argv[4]);
	    if (sid > 0)
	      status = id_to_name(sid, "USER", &argv[4]);
	    else
	      status = id_to_name(-sid, "STRING", &argv[4]);
	}
	if (status && status != MR_NO_MATCH) return(status);

	(*action)(q->vcnt, argv, actarg);
    skip:
	/* free saved data */
	free(argv[0]);
	free(argv[1]);
	free(argv[4]);
	free(argv);
    }

    sq_destroy(sq);
    return (MR_SUCCESS);
}


/* followup_glin: fix the ace_name in argv[8].  argv[7] will contain the
 * ace_type: "LIST", "USER", or "NONE".  Decode the id in argv[8] into the
 * proper name based on the type, and repace that string in the argv.
 * Also fixes the modby field by called followup_fix_modby.
 */

followup_glin(q, sq, v, action, actarg, cl)
    register struct query *q;
    register struct save_queue *sq;
    register struct validate *v;
    register int (*action)();
    int actarg;
    client *cl;
{
    char **argv, *malloc(), *realloc(), *type;
    int id, i, idx, status;

    idx = 8;
    if (!strcmp(q->shortname, "gsin"))
      idx = 12;

    while (sq_get_data(sq, &argv)) {
	mr_trim_args(q->vcnt, argv);

	id = atoi(argv[i = q->vcnt - 2]);
	if (id > 0)
	  status = id_to_name(id, "USER", &argv[i]);
	else
	  status = id_to_name(-id, "STRING", &argv[i]);
	if (status && status != MR_NO_MATCH)
	  return(status);

	id = atoi(argv[idx]);
	type = argv[idx - 1];

	if (!strcmp(type, "LIST")) {
	    status = id_to_name(id, "LIST", &argv[idx]);
	} else if (!strcmp(type, "USER")) {
	    status = id_to_name(id, "USER", &argv[idx]);
	} else if (!strcmp(type, "KERBEROS")) {
	    status = id_to_name(id, "STRING", &argv[idx]);
	} else if (!strcmp(type, "NONE")) {
	    status = 0;
	    free(argv[idx]);
	    argv[idx] = strsave("NONE");
	} else {
	    status = 0;
	    free(argv[idx]);
	    argv[idx] = strsave("???");
	}
	if (status && status != MR_NO_MATCH)
	  return(status);

	if (!strcmp(q->shortname, "glin") && atoi(argv[6]) == -1) {
	    argv[6] = realloc(argv[6], strlen(UNIQUE_GID) + 1);
	    strcpy(argv[6], UNIQUE_GID);
	}

	/* send the data */
	(*action)(q->vcnt, argv, actarg);

	/* free saved data */
	for (i = 0; i < q->vcnt; i++) 
	    free(argv[i]);
	free(argv);
    }

    sq_destroy(sq);
    return (MR_SUCCESS);
}


/* followup_gqot: Fix the entity name, directory name & modby fields
 *   argv[0] = filsys_id
 *   argv[1] = type
 *   argv[2] = entity_id
 *   argv[3] = ascii(quota)
 */

followup_gqot(q, sq, v, action, actarg, cl)
    struct query *q;
    register struct save_queue *sq;
    struct validate *v;
    register int (*action)();
    register int actarg;
    client *cl;
{
    register int j;
    char **argv, *malloc();
    EXEC SQL BEGIN DECLARE SECTION;
    int id, rowcount;
    char *name, *label;
    EXEC SQL END DECLARE SECTION;
    int status, idx;

    if (!strcmp(q->name, "get_quota") ||
	!strcmp(q->name, "get_quota_by_filesys"))
      idx = 4;
    else
      idx = 3;
    while (sq_get_data(sq, &argv)) {
	if (idx == 4) {
	    switch (argv[1][0]) {
	    case 'U':
		status = id_to_name(atoi(argv[2]), "USER", &argv[2]);
		break;
	    case 'G':
	    case 'L':
		status = id_to_name(atoi(argv[2]), "LIST", &argv[2]);
		break;
	    case 'A':
		free(argv[2]);
		argv[2] = strsave("system:anyuser");
		break;
	    default:
		id = atoi(argv[2]);
		argv[2] = malloc(8);
		sprintf(argv[2], "%d", id);
	    }
	}
	id = atoi(argv[idx]);
	free(argv[idx]);
	argv[idx] = malloc(256);
	name = argv[idx];
	if (id == 0) {
	    label = argv[0];
            EXEC SQL SELECT name
                     INTO :name
                     FROM filesys
                     WHERE label = :label;
	} else {
            EXEC SQL SELECT dir
                     INTO :name
                     FROM nfsphys
                     WHERE nfsphys_id = :id;
	}
        if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1) {
	    sprintf(argv[idx], "#%d", id);
	}

	id = atoi(argv[idx+3]);
	if (id > 0)
	  status = id_to_name(id, "USER", &argv[idx+3]);
	else
	  status = id_to_name(-id, "STRING", &argv[idx+3]);
	if (status && status != MR_NO_MATCH)
	  return(status);
	(*action)(q->vcnt, argv, actarg);
	for (j = 0; j < q->vcnt; j++)
	  free(argv[j]);
	free(argv);
    }
    sq_destroy(sq);
    return(MR_SUCCESS);
}


/* followup_aqot: Add allocation to nfsphys after creating quota.
 *   argv[0] = filsys_id
 *   argv[1] = type if "add_quota" or "update_quota"
 *   argv[2 or 1] = id
 *   argv[3 or 2] = ascii(quota)
 */

followup_aqot(q, argv, cl)
    struct query  *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int quota, id, fs, who;
    char *entity, *qtype;
    EXEC SQL END DECLARE SECTION;

    fs = *(int *)argv[0];
    if (!strcmp(q->name, "add_quota") || !strcmp(q->name, "update_quota")) {
	qtype = argv[1];
	id = *(int *)argv[2];
	quota = atoi(argv[3]);
    } else {
	qtype = "USER";
	id = *(int *)argv[1];
	quota = atoi(argv[2]);
    }
    who = cl->client_id;
    entity = cl->entity;

##  repeat replace q (modtime = "now", modby = @who, modwith = @entity)
##	where q.filsys_id = @fs and q.type = @qtype and q.entity_id = @id
##  repeat replace nfsphys (allocated = nfsphys.allocated + @quota)
##	where nfsphys.nfsphys_id = filesys.#phys_id and filesys.filsys_id = @fs
    if (ingres_errno) return(mr_errcode);
    return(MR_SUCCESS);
}


followup_gpce(q, sq, v, action, actarg, cl)
    struct query *q;
    register struct save_queue *sq;
    struct validate *v;
    register int (*action)();
    register int actarg;
    client *cl;
{
    register int i, j;
    char **argv, *malloc();
    int id, status;

    i = q->vcnt - 2;
    while (sq_get_data(sq, &argv)) {
	id = atoi(argv[PCAP_QSERVER]);
	status = id_to_name(id, "MACHINE", &argv[PCAP_QSERVER]);
	if (status) return (status);
	id = atoi(argv[i]);
	if (id > 0)
	  status = id_to_name(id, "USER", &argv[i]);
	else
	  status = id_to_name(-id, "STRING", &argv[i]);
	if (status && status != MR_NO_MATCH)
	  return(status);
	(*action)(q->vcnt, argv, actarg);
	for (j = 0; j < q->vcnt; j++)
	  free(argv[j]);
	free(argv);
    }
    sq_destroy(sq);
    return(MR_SUCCESS);
}


/* followup_gzcl:
 */

followup_gzcl(q, sq, v, action, actarg, cl)
    register struct query *q;
    register struct save_queue *sq;
    register struct validate *v;
    register int (*action)();
    int actarg;
    client *cl;
{
    int id, i, status;
    char **argv;

    while (sq_get_data(sq, &argv)) {
	mr_trim_args(q->vcnt, argv);

	id = atoi(argv[i = q->vcnt - 2]);
	if (id > 0)
	  status = id_to_name(id, "USER", &argv[i]);
	else
	  status = id_to_name(-id, "STRING", &argv[i]);
	if (status && status != MR_NO_MATCH)
	  return(status);

	for (i = 1; i < 8; i+=2) {
	    id = atoi(argv[i+1]);
	    if (!strcmp(argv[i], "LIST")) {
		status = id_to_name(id, "LIST", &argv[i+1]);
	    } else if (!strcmp(argv[i], "USER")) {
		status = id_to_name(id, "USER", &argv[i+1]);
	    } else if (!strcmp(argv[i], "KERBEROS")) {
		status = id_to_name(id, "STRING", &argv[i+1]);
	    } else if (!strcmp(argv[i], "NONE")) {
		status = 0;
		free(argv[i+1]);
		argv[i+1] = strsave("NONE");
	    } else {
		status = 0;
		free(argv[i+1]);
		argv[i+1] = strsave("???");
	    }
	    if (status && status != MR_NO_MATCH)
	      return(status);
	}

	/* send the data */
	(*action)(q->vcnt, argv, actarg);

	/* free saved data */
	for (i = 0; i < q->vcnt; i++) 
	    free(argv[i]);
	free(argv);
    }
    sq_destroy(sq);
    return(MR_SUCCESS);
}


/* followup_gsha:
 */

followup_gsha(q, sq, v, action, actarg, cl)
    register struct query *q;
    register struct save_queue *sq;
    register struct validate *v;
    register int (*action)();
    int actarg;
    client *cl;
{
    char **argv;
    int i, id, status;

    while (sq_get_data(sq, &argv)) {
	mr_trim_args(q->vcnt, argv);

	id = atoi(argv[4]);
	if (id > 0)
	  status = id_to_name(id, "USER", &argv[4]);
	else
	  status = id_to_name(-id, "STRING", &argv[4]);
	if (status && status != MR_NO_MATCH)
	  return(status);

	id = atoi(argv[2]);
	if (!strcmp(argv[1], "LIST")) {
	    status = id_to_name(id, "LIST", &argv[2]);
	} else if (!strcmp(argv[1], "USER")) {
	    status = id_to_name(id, "USER", &argv[2]);
	} else if (!strcmp(argv[1], "KERBEROS")) {
	    status = id_to_name(id, "STRING", &argv[2]);
	} else if (!strcmp(argv[1], "NONE")) {
	    status = 0;
	    free(argv[2]);
	    argv[2] = strsave("NONE");
	} else {
	    status = 0;
	    free(argv[2]);
	    argv[2] = strsave("???");
	}
	if (status && status != MR_NO_MATCH)
	  return(status);

	/* send the data */
	(*action)(q->vcnt, argv, actarg);

	/* free saved data */
	for (i = 0; i < q->vcnt; i++) 
	    free(argv[i]);
	free(argv);
    }
    sq_destroy(sq);
    return(MR_SUCCESS);
}



/* Special query routines */

/* set_pobox - this does all of the real work.
 *	 argv = user_id, type, box
 * if type is POP, then box should be a machine, and its ID should be put in
 * pop_id.  If type is SMTP, then box should be a string and its ID should
 * be put in box_id.  If type is NONE, then box doesn't matter.
 */

int set_pobox(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int user, id;
    char *box, potype[9];
    EXEC SQL END DECLARE SECTION;
    int status;

    box = argv[2];
    user = *(int *)argv[0];
    EXEC SQL SELECT pop_id, potype
             INTO :id, :potype
             FROM users
             WHERE users_id = :user;
    if (ingres_errno) return(mr_errcode);
    if (!strcmp(strtrim(potype), "POP"))
      set_pop_usage(id, -1);

    if (!strcmp(argv[1], "POP")) {
	status = name_to_id(box, "MACHINE", &id);
	if (status == MR_NO_MATCH)
	  return(MR_MACHINE);
	else if (status)
	  return(status);
##	repeat replace users (#potype = "POP", pop_id = @id)
##		where users.users_id = @user
	set_pop_usage(id, 1);
    } else if (!strcmp(argv[1], "SMTP")) {
	if (index(box, '/') || index(box, '|'))
	  return(MR_BAD_CHAR);
	status = name_to_id(box, "STRING", &id);
	if (status == MR_NO_MATCH) {
            EXEC SQL SELECT value 
                     INTO :id 
                     FROM values_tbl 
                     WHERE name =  "strings_id";
	    id++;
##          repeat replace values_tbl.(value = @id) where values_tbl.name = "strings_id"
##	    append to strings (string_id = id, string = box)
	} else if (status)
	  return(status);
##	repeat replace users (#potype = "SMTP", box_id = @id) 
##	       where users.users_id = @user
    } else /* argv[1] == "NONE" */ {
##	repeat replace users (#potype = "NONE") where users.users_id = @user
    }

    set_pobox_modtime(q, argv, cl);
##  repeat replace tblstats (updates = tblstats.updates + 1, modtime = "now")
##	where tblstats.#table = "users"
    if (ingres_errno) return(mr_errcode);
    return(MR_SUCCESS);
}


/* get_list_info:  passed a wildcard list name, returns lots of stuff about
 * each list.  This is tricky:  first build a queue of all requested
 * data.  Rest of processing consists of fixing gid, ace_name, and modby.
 */

get_list_info(q, aargv, cl, action, actarg)
    register struct query *q;
    char **aargv;
    client *cl;
    register int (*action)();
    int actarg;
{
    char *argv[13], *malloc(), *realloc();
    EXEC SQL BEGIN DECLARE SECTION;
    char *name, acl_type[9], listname[33], active[5], public[5], hidden[5];
    char maillist[5], grp[5], gid[6], acl_name[256], desc[256], modtime[27];
    char modby[256], modwith[9];
    int id, rowcount, acl_id, hid, modby_id;
    EXEC SQL END DECLARE SECTION;
    int returned, status;
    struct save_queue *sq, *sq_create();

    returned = rowcount = 0;
    name = aargv[0];

    sq = sq_create();
    EXEC SQL DECLARE l_cursor CURSOR FOR
          SELECT L.list_id
          FROM LIST L
          WHERE L.name = :name;
    EXEC SQL OPEN l_cursor;
    while (1) {
        EXEC SQL FETCH l_cursor INTO :id;
        if (sqlca.sqlcode != 0) break;
	sq_save_data(sq, id);
	rowcount++;
    }
    EXEC SQL CLOSE l_cursor;
    if (ingres_errno) return(mr_errcode);
    if (rowcount == 0)
      return(MR_NO_MATCH);

    argv[0] = listname; argv[1] = active; argv[2] = public; argv[3] = hidden;
    argv[4] = maillist; argv[5] = grp; argv[6] = gid; argv[7] = acl_type;
    argv[9] = desc; argv[10] = modtime; argv[12] = modwith;

    while (sq_get_data(sq, &id)) {
	if (id == 0)
	  continue;
	argv[6] = gid;
##	repeat retrieve (listname = l.#name, active = text(l.#active), 
##		public = text(l.#public), hidden = text(l.#hidden),
##		hid = l.#hidden, maillist = text(l.#maillist),
##		group = text(l.#grp), gid = text(l.#gid),
##		acl_type = trim(l.#acl_type), acl_id = l.#acl_id,
##		desc = l.#desc, modtime = l.#modtime, modby_id = l.#modby,
##		modwith =l.#modwith)
##	    where l.list_id = @id
	if (ingres_errno) return(mr_errcode);

	if (atoi(gid) == -1)
	    argv[6] = UNIQUE_GID;

	argv[8] = malloc(0);
	if (!strcmp(acl_type, "LIST")) {
	    status = id_to_name(acl_id, "LIST", &argv[8]);
	} else if (!strcmp(acl_type, "USER")) {
	    status = id_to_name(acl_id, "USER", &argv[8]);
	} else if (!strcmp(acl_type, "KERBEROS")) {
	    status = id_to_name(acl_id, "STRING", &argv[8]);
	} else if (!strcmp(acl_type, "NONE")) {
	    status = 0;
	    free(argv[8]);
	    argv[8] = strsave("NONE");
	} else {
	    status = 0;
	    free(argv[8]);
	    argv[8] = strsave("???");
	}
	if (status && status != MR_NO_MATCH) return(status);

	argv[11] = malloc(0);
	if (modby_id > 0)
	  status = id_to_name(modby_id, "USER", &argv[11]);
	else
	  status = id_to_name(-modby_id, "STRING", &argv[11]);
	if (status && status != MR_NO_MATCH) return(status);

	mr_trim_args(q->vcnt, argv);
	returned++;
	(*action)(q->vcnt, argv, actarg);
	free(argv[8]);
	free(argv[11]);
    }

    sq_destroy(sq);
    if (ingres_errno) return(mr_errcode);
    return (MR_SUCCESS);
}


/* Add_member_to_list: do list flattening as we go!  MAXLISTDEPTH is
 * how many different ancestors a member is allowed to have.
 */

#define MAXLISTDEPTH	1024

int add_member_to_list(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id, lid, mid, exist, error, who, ref;
    char *mtype, dtype[9], *entity;
    EXEC SQL END DECLARE SECTION;
    int ancestors[MAXLISTDEPTH], aref[MAXLISTDEPTH], acount, a;
    int descendants[MAXLISTDEPTH], dref[MAXLISTDEPTH], dcount, d;
    int status;
    char *dtypes[MAXLISTDEPTH];
    char *iargv[3], *buf;

    EXEC SQL DECLARE m_cursor_a CURSOR FOR
          SELECT M.list_id, M.ref_count
          FROM IMEMBERS M
          WHERE M.member_id = :lid AND M.member_type = "LIST";
    EXEC SQL OPEN m_cursor_a;

    lid = *(int *)argv[0];
    mtype = argv[1];
    mid = *(int *)argv[2];
    /* if the member is already a direct member of the list, punt */
##  repeat retrieve (exist = any(m.list_id where m.list_id=@lid and 
##			   m.member_id = @mid and m.member_type = @mtype
##			   and m.direct = 1))
    if (exist)
      return(MR_EXISTS);
    if (!strcasecmp(mtype, "STRING")) {
	buf = malloc(0);
	status = id_to_name(mid, "STRING", &buf);
	if (status) return(status);
	if (index(buf, '/') || index(buf, '|')) {
	    free(buf);
	    return(MR_BAD_CHAR);
	}
	free(buf);
    }

    ancestors[0] = lid;
    aref[0] = 1;
    acount = 1;
    while (1) {
        EXEC SQL FETCH m_cursor_a INTO :id, :ref;
        if (sqlca.sqlcode != 0) break;
	aref[acount] = ref;
	ancestors[acount++] = id;
	if (acount >= MAXLISTDEPTH) {
           return(MR_INTERNAL);
	}
    }
    if (ingres_errno) return(mr_errcode);
    if (acount >= MAXLISTDEPTH) {
	return(MR_INTERNAL);
    }
    EXEC SQL CLOSE m_cursor_a;
    descendants[0] = mid;
    dtypes[0] = mtype;
    dref[0] = 1;
    dcount = 1;
    error = 0;


    if (!strcmp(mtype, "LIST")) {
        EXEC SQL DECLARE m_cursor_l CURSOR FOR
             SELECT M.member_id, M.memeber_type, M.ref_count
             FROM IMEMBERS M
             WHERE M.list_id = :mid;
        EXEC SQL OPEN m_cursor_l;
        while (1) {
            EXEC SQL FETCH m_cursor_l INTO :id, :dtype, :ref;
            if (sqlca.sqlcode != 0) break;
	    switch (dtype[0]) {
	    case 'L':
		dtypes[dcount] = "LIST";
		break;
	    case 'U':
		dtypes[dcount] = "USER";
		break;
	    case 'S':
		dtypes[dcount] = "STRING";
		break;
	    case 'K':
		dtypes[dcount] = "KERBEROS";
		break;
	    default:
		error++;
	    }
	    dref[dcount] = ref;
	    descendants[dcount++] = id;
	    if (dcount >= MAXLISTDEPTH) {
		error++;
	    }
  	}
        EXEC SQL CLOSE m_cursor_l;
	if (ingres_errno) return(mr_errcode);
	if (error)
	  return(MR_INTERNAL);
    }
    for (a = 0; a < acount; a++) {
	lid = ancestors[a];
	for (d = 0; d < dcount; d++) {
	    mid = descendants[d];
	    mtype = dtypes[d];
	    if (mid == lid && !strcmp(mtype, "LIST")) {
		return(MR_LISTLOOP);
	    }
##	    repeat retrieve (exist = any(m.ref_count where m.list_id = @lid
##					 and m.member_id = @mid
##					 and m.member_type = @mtype))
	    ref = aref[a] * dref[d];
	    if (exist) {
		if (a == 0 && d == 0)
##		  replace m (ref_count = m.ref_count+ref, direct = 1)
##			     where m.list_id = lid and m.member_id = mid and
##			     m.member_type = mtype
		else
##		  replace m (ref_count = m.ref_count+ref)
##			     where m.list_id = lid and m.member_id = mid and
##			     m.member_type = mtype
	    } else {
		incremental_clear_before();
		if (a == 0 && d == 0)
##		  append imembers (list_id=lid, member_id = mid, direct = 1,
##				   member_type=mtype, ref_count = 1)
		else
##		  append imembers (list_id=lid, member_id = mid,
##				   member_type=mtype, ref_count = ref)
		iargv[0] = (char *)lid;
		iargv[1] = mtype;
		iargv[2] = (char *)mid;
		incremental_after("members", 0, iargv);
	    }
	}
    }
    lid = *(int *)argv[0];
    entity = cl->entity;
    who = cl->client_id;
##  repeat replace list (modtime = "now", modby = @who, modwith = @entity)
##	 where list.#list_id = @lid
    if (ingres_errno) return(mr_errcode);
    return(MR_SUCCESS);
}


/* Delete_member_from_list: do list flattening as we go!
 */

int delete_member_from_list(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id, lid, mid, cnt, exist, error, who, ref;
    char *mtype, dtype[9], *entity;
    EXEC SQL END DECLARE SECTION;
    int ancestors[MAXLISTDEPTH], aref[MAXLISTDEPTH], acount, a;
    int descendants[MAXLISTDEPTH], dref[MAXLISTDEPTH], dcount, d;
    char *dtypes[MAXLISTDEPTH];
    char *iargv[3];

##  range of m is imembers
    lid = *(int *)argv[0];
    mtype = argv[1];
    mid = *(int *)argv[2];
    /* if the member is not a direct member of the list, punt */
##  repeat retrieve (exist = any(m.list_id where m.list_id=@lid and 
##			   m.member_id = @mid and m.member_type = @mtype
##			   and m.direct = 1))
    if (ingres_errno) return(mr_errcode);
    if (!exist)
      return(MR_NO_MATCH);
    ancestors[0] = lid;
    aref[0] = 1;
    acount = 1;

    EXEC SQL DECLARE m3_cursor CURSOR FOR
         SELECT M.list_id, M.ref_count
         FROM IMEMBERS M
         WHERE M.member_id = :lid AND M.member_type = "LIST";
    EXEC SQL OPEN m3_cursor;
    while (1) {
        EXEC SQL FETCH m3_cursor INTO :id, :ref;
        if (sqlca.sqlcode != 0) break;
        aref[acount] = ref;
	ancestors[acount++] = id;
	if (acount >= MAXLISTDEPTH)
          break; 
    }
    EXEC SQL CLOSE m3_cursor;
    if (ingres_errno) return(mr_errcode);
    if (acount >= MAXLISTDEPTH)
      return(MR_INTERNAL);
    descendants[0] = mid;
    dtypes[0] = mtype;
    dref[0] = 1;
    dcount = 1;
    error = 0;
    if (!strcmp(mtype, "LIST")) {
        EXEC SQL DECLARE m4_cursor CURSOR FOR
             SELECT M.member_id, M.memeber_type, M.ref_count
             FROM IMEMBERS M
             WHERE M.list_id = :mid;
        EXEC SQL OPEN m4_cursor;
        while (1) {
            EXEC SQL FETCH m4_cursor INTO :id, :dtype, :ref;
            if (sqlca.sqlcode != 0) break;
	    switch (dtype[0]) {
	    case 'L':
		dtypes[dcount] = "LIST";
		break;
	    case 'U':
		dtypes[dcount] = "USER";
		break;
	    case 'S':
		dtypes[dcount] = "STRING";
		break;
	    case 'K':
		dtypes[dcount] = "KERBEROS";
		break;
	    default:
		error++;
	    }
	    dref[dcount] = ref;
	    descendants[dcount++] = id;
	    if (dcount >= MAXLISTDEPTH)
               break;
        }
        EXEC SQL CLOSE m4_cursor;
	if (ingres_errno) return(mr_errcode);
	if (error)
	  return(MR_INTERNAL);
    }
    EXEC SQL DECLARE m5_cursor CURSOR FOR
     SELECT M.ref_count
     FROM IMEMBERS M
     WHERE M.list_id = :lid AND M.member_id = :mid AND M.member_type = :mtype;
    EXEC SQL OPEN m5_cursor;
    for (a = 0; a < acount; a++) {
	lid = ancestors[a];
	for (d = 0; d < dcount; d++) {
	    mid = descendants[d];
	    mtype = dtypes[d];
	    if (mid == lid && !strcmp(mtype, "LIST")) {
		return(MR_LISTLOOP);
	    }
            EXEC SQL FETCH m5_cursor INTO :cnt;
            if (sqlca.sqlcode != 0) break;
	    ref = aref[a] * dref[d];
	    if (cnt <= ref) {
		iargv[0] = (char *)lid;
		iargv[1] = mtype;
		iargv[2] = (char *)mid;
		incremental_before("members", 0, iargv);
                EXEC SQL DELETE 
                 FROM IMEMBERS 
                 WHERE list_id = :lid AND member_id = :mid 
                    AND member_type = :mtype;
		incremental_clear_after();
	    } else if (a == 0 && d == 0) {
                EXEC SQL UPDATE imembers
                 SET ref_count = ref_count - :ref, direct = 0
                 WHERE list_id = :lid AND member_id = :mid 
                    AND member_type = :mtype;
	    } else {
                EXEC SQL UPDATE imembers
                 SET ref_count = ref_count - :ref
                 WHERE list_id = :lid AND member_id = :mid 
                    AND member_type = :mtype;
	    }
	}
    }
    EXEC SQL CLOSE m5_cursor;
    lid = *(int *)argv[0];
    entity = cl->entity;
    who = cl->client_id;
    EXEC SQL UPDATE list
         SET modtime = "now", modby = :who, modwith = :entity
         WHERE list = :list_id;
    if (ingres_errno) return(mr_errcode);
    return(MR_SUCCESS);
}


/* get_ace_use - given a type and a name, return a type and a name.
 * The ace_type is one of "LIST", "USER", "RLIST", or "RUSER" in argv[0],
 * and argv[1] will contain the ID of the entity in question.  The R*
 * types mean to recursively look at every containing list, not just
 * when the object in question is a direct member.  On return, the
 * usage type will be one of LIST, SERVICE, FILESYS, QUOTA, QUERY, or ZEPHYR.
 */

int get_ace_use(q, argv, cl, action, actarg)
    struct query *q;
    char *argv[];
    client *cl;
    int (*action)();
    int actarg;
{
    int found = 0;
    EXEC SQL BEGIN DECLARE SECTION;
    char *atype;
    int aid, listid, id;
    EXEC SQL END DECLARE SECTION;
    struct save_queue *sq, *sq_create();

    atype = argv[0];
    aid = *(int *)argv[1];
    if (!strcmp(atype, "LIST") || !strcmp(atype, "USER") ||
	!strcmp(atype, "KERBEROS")) {
	return(get_ace_internal(atype, aid, action, actarg));
    }

    sq = sq_create();
    if (!strcmp(atype, "RLIST")) {
	sq_save_data(sq, aid);
	/* get all the list_id's of containing lists */
        EXEC SQL DECLARE m6_cursor CURSOR FOR
         SELECT M.list_id
         FROM IMEMBERS M
         WHERE M.member_type = "LIST" AND M.member_id = :id;
        EXEC SQL OPEN m6_cursor;
        while (1) {
            EXEC SQL FETCH m6_cursor INTO :listid;
            if (sqlca.sqlcode != 0) break;
	    sq_save_unique_data(sq, listid);
	}
	/* now process each one */
	while (sq_get_data(sq, &id)) {
	    if (get_ace_internal("LIST", id, action, actarg) == MR_SUCCESS)
	      found++;
	}
    EXEC SQL CLOSE m6_cursor;
    }

    if (!strcmp(atype, "RUSER")) {
        EXEC SQL DECLARE m7_cursor CURSOR FOR
         SELECT M.list_id
         FROM IMEMBERS M
         WHERE M.member_type = "USER" AND M.member_id = :aid;
        EXEC SQL OPEN m7_cursor;
        while (1) {
            EXEC SQL FETCH m7_cursor INTO :listid;
            if (sqlca.sqlcode != 0) break;
	    sq_save_data(sq, listid);
	}
	/* now process each one */
	while (sq_get_data(sq, &id)) {
	    if (get_ace_internal("LIST", id, action, actarg) == MR_SUCCESS)
	      found++;
	}
	if (get_ace_internal("USER", aid, action, actarg) == MR_SUCCESS)
	  found++;
    EXEC SQL CLOSE m7_cursor;
    }

    if (!strcmp(atype, "RKERBERO")) {
        EXEC SQL DECLARE m8_cursor CURSOR FOR
         SELECT M.list_id
         FROM IMEMBERS M
         WHERE M.member_type = "KERBEROS" AND M.member_id = :aid;
        EXEC SQL OPEN m8_cursor;
        while (1) {
            EXEC SQL FETCH m8_cursor INTO :listid;
            if (sqlca.sqlcode != 0) break;
	    sq_save_data(sq, listid);
	}
	/* now process each one */
	while (sq_get_data(sq, &id)) {
	    if (get_ace_internal("LIST", id, action, actarg) == MR_SUCCESS)
	      found++;
	}
	if (get_ace_internal("KERBEROS", aid, action, actarg) == MR_SUCCESS)
	  found++;
    EXEC SQL CLOSE m8_cursor;
    }

    sq_destroy(sq);	
    if (ingres_errno) return(mr_errcode);
    if (!found) return(MR_NO_MATCH);
    return(MR_SUCCESS);
}


/* This looks up a single list or user for ace use.  atype must be "USER"
 * or "LIST", and aid is the ID of the corresponding object.  This is used
 * by get_ace_use above.
 */

##get_ace_internal(atype, aid, action, actarg)
    EXEC SQL BEGIN DECLARE SECTION;
    char *atype;
    int aid;
    EXEC SQL END DECLARE SECTION;
    int (*action)();
    int actarg;
{
    char *rargv[2];
    int found = 0;
    EXEC SQL BEGIN DECLARE SECTION;
    char name[33];
    EXEC SQL END DECLARE SECTION;

    rargv[1] = name;
    EXEC SQL DECLARE F1_cursor CURSOR FOR
         SELECT F.label
         FROM FILESYS F
         WHERE F.owners = :aid;
    EXEC SQL OPEN F1_cursor;

    EXEC SQL DECLARE C1_cursor CURSOR FOR
         SELECT C.capability
         FROM CAPACLS C
         WHERE C.list_id = :aid;
    EXEC SQL OPEN C1_cursor;

    if (!strcmp(atype, "LIST")) {
	rargv[0] = "FILESYS";
        while (1) {
            EXEC SQL FETCH F1_cursor INTO :name;
            if (sqlca.sqlcode != 0) break;
	    (*action)(2, rargv, actarg);
	    found++;
	}
	rargv[0] = "QUERY";
        while (1) {
            EXEC SQL FETCH C1_cursor INTO :name;
            if (sqlca.sqlcode != 0) break;
	    (*action)(2, rargv, actarg);
	    found++;
	}
    } else if (!strcmp(atype, "USER")) {
	rargv[0] = "FILESYS";
        while (1) {
            EXEC SQL FETCH F1_cursor INTO :name;
            if (sqlca.sqlcode != 0) break;
	    (*action)(2, rargv, actarg);
	    found++;
	}
    }
    EXEC SQL CLOSE F1_cursor;
    EXEC SQL CLOSE C1_cursor;

    rargv[0] = "LIST";
    EXEC SQL DECLARE l8_cursor CURSOR FOR
         SELECT L.name
         FROM LIST L
         WHERE L.acl_type = :atype AND L.acl_id = :aid;
    EXEC SQL OPEN l8_cursor;

    while (1) {
         EXEC SQL FETCH l8_cursor INTO :name;
         if (sqlca.sqlcode != 0) break;
	 (*action)(2, rargv, actarg);
	 found++;
    }
    EXEC SQL CLOSE l8_cursor;

    rargv[0] = "SERVICE";
    EXEC SQL DECLARE s_cursor CURSOR FOR
         SELECT S.name
         FROM SERVERS S
         WHERE S.acl_type = :atype AND S.acl_id = :aid;
    EXEC SQL OPEN s_cursor;

    while (1) {
         EXEC SQL FETCH s_cursor INTO :name;
         if (sqlca.sqlcode != 0) break;
	 (*action)(2, rargv, actarg);
	 found++;
    }
    EXEC SQL CLOSE s_cursor;

    rargv[0] = "HOSTACCESS";
    EXEC SQL DECLARE h_cursor CURSOR FOR
         SELECT M.name
         FROM MACHINE M, HOSTACCESS H
         WHERE M.mach_id = H.mach_id 
             AND H.acl_type = :atype AND H.acl_id = :aid;
    EXEC SQL OPEN h_cursor;
    while (1) {
        EXEC SQL FETCH h_cursor INTO :name;
        if (sqlca.sqlcode != 0) break;
	(*action)(2, rargv, actarg);
	found++;
    }
    EXEC SQL CLOSE h_cursor;

    rargv[0] = "ZEPHYR";
    EXEC SQL DECLARE z_cursor CURSOR FOR
         SELECT Z.class
         FROM ZEPHYR Z
         WHERE Z.xmt_type = :atype AND Z.xmt_id = :aid OR
            Z.sub_type = :atype AND Z.sub_id = :aid OR
            Z.iws_type = :atype AND Z.iws_id = :aid OR
            Z.iui_type = :atype AND Z.iui_id = :aid;

    EXEC SQL OPEN z_cursor;
    while (1) {
         EXEC SQL FETCH h_cursor INTO :name;
         if (sqlca.sqlcode != 0) break;
	 (*action)(2, rargv, actarg);
	 found++;
    }
    EXEC SQL CLOSE z_cursor;

    if (!found) return(MR_NO_MATCH);
    return(MR_SUCCESS);
}


/* get_lists_of_member - given a type and a name, return the name and flags
 * of all of the lists of the given member.  The member_type is one of
 * "LIST", "USER", "STRING", "RLIST", "RUSER", or "RSTRING" in argv[0],
 * and argv[1] will contain the ID of the entity in question.  The R*
 * types mean to recursively look at every containing list, not just
 * when the object in question is a direct member.
 */

int get_lists_of_member(q, argv, cl, action, actarg)
    struct query *q;
    char *argv[];
    client *cl;
    int (*action)();
    int actarg;
{
    int found = 0, direct = 1;
    char *rargv[6];
    EXEC SQL BEGIN DECLARE SECTION;
    char *atype;
    int aid, listid, id;
    char name[33], active[5], public[5], hidden[5], maillist[5], grp[5];
    EXEC SQL END DECLARE SECTION;

    atype = argv[0];
    aid = *(int *)argv[1];
    if (!strcmp(atype, "RLIST")) {
	atype = "LIST";
	direct = 0;
    }
    if (!strcmp(atype, "RUSER")) {
	atype = "USER";
	direct = 0;
    }
    if (!strcmp(atype, "RSTRING")) {
	atype = "STRING";
	direct = 0;
    }
    if (!strcmp(atype, "RKERBEROS")) {
	atype = "KERBEROS";
	direct = 0;
    }

    rargv[0] = name;
    rargv[1] = active;
    rargv[2] = public;
    rargv[3] = hidden;
    rargv[4] = maillist;
    rargv[5] = grp;
##  range of m is imembers
    if (direct) {
##    repeat retrieve (name = list.#name, active = text(list.#active), 
##		     public = text(list.#public), hidden = text(list.#hidden),
##		     maillist = text(list.#maillist), grp = text(list.#group))
##		where list.list_id = m.list_id and m.direct = 1 and
##		      m.member_type = @atype and m.member_id = @aid {
	 (*action)(6, rargv, actarg);
	 found++;
##    }
    } else {
##    repeat retrieve (name = list.#name, active = text(list.#active), 
##		     public = text(list.#public), hidden = text(list.#hidden),
##		     maillist = text(list.#maillist), grp = text(list.#group))
##		where list.list_id = m.list_id and
##		      m.member_type = @atype and m.member_id = @aid {
	 (*action)(6, rargv, actarg);
	 found++;
##    }
    }

    if (ingres_errno) return(mr_errcode);
    if (!found) return(MR_NO_MATCH);
    return(MR_SUCCESS);
##}


/* qualified_get_lists: passed "TRUE", "FALSE", or "DONTCARE" for each of
 * the five flags associated with each list.  It will return the name of
 * each list that meets the quailifications.  It does this by building a
 * where clause based on the arguments, then doing a retrieve.
 */

static char *lflags[5] = { "active", "public", "hidden", "maillist", "group" };

int qualified_get_lists(q, argv, cl, action, actarg)
    struct query *q;
    char *argv[];
    client *cl;
    int (*action)();
    int actarg;
{
    return(qualified_get(q, argv, action, actarg, "l.list_id != 0",
			 "l", "name", lflags));
}


/** get_members_of_list - optimized query for retrieval of list members
 **
 ** Inputs:
 **   argv[0] - list_id
 **
 ** Description:
 **   - retrieve USER members, then LIST members, then STRING members
 **/

get_members_of_list(q, argv, cl, action, actarg)
    struct query *q;
    char *argv[];
    client *cl;
    int (*action)();
    int actarg;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int list_id, member_id;
    char member_name[129], member_type[9];
    EXEC SQL END DECLARE SECTION;
    char *targv[2];
    int members;
    struct save_queue *sq;

    list_id = *(int *)argv[0];
    members = 0;
    sq = sq_create();

    EXEC SQL DECLARE m9_cursor CURSOR FOR
         SELECT M.member_type, M.member_id
         FROM IMEMBERS M
         WHERE M.list_id = :list_id AND M.direct = 1;
    EXEC SQL OPEN m9_cursor;
    while (1) {
      EXEC SQL FETCH m9_cursor INTO :member_type, :member_id;
      if (sqlca.sqlcode != 0) break;
      if (members++ > 49)
         break;
      sq_save_data(sq, (member_type[0] << 24) | (member_id & 0xffffff));
    }
    EXEC SQL CLOSE m9_cursor;
    if (members <= 49) {
	targv[1] = malloc(0);
	while (sq_remove_data(sq, &member_id)) {
	    switch (member_id >> 24) {
	    case 'U':
		targv[0] = "USER";
		id_to_name(member_id & 0xffffff, "USER", &targv[1]);
		(*action)(2, targv, actarg);
		break;
	    case 'L':
		targv[0] = "LIST";
		id_to_name(member_id & 0xffffff, "LIST", &targv[1]);
		(*action)(2, targv, actarg);
		break;
	    case 'S':
		targv[0] = "STRING";
		id_to_name(member_id & 0xffffff, "STRING", &targv[1]);
		(*action)(2, targv, actarg);
		break;
	    case 'K':
		targv[0] = "KERBEROS";
		id_to_name(member_id & 0xffffff, "STRING", &targv[1]);
		(*action)(2, targv, actarg);
		break;
	    default:
		sq_destroy(sq);
		return(MR_INTERNAL);
	    }
	}
	free(targv[1]);
	sq_destroy(sq);
	return(MR_SUCCESS);
    }
    sq_destroy(sq);

    targv[1] = member_name;
    targv[0] = "USER";
##  range of m is imembers
##  repeat retrieve (member_name = users.login)
##             where m.#list_id = @list_id and m.#member_type = "USER"
##                   and m.#member_id = users.users_id and m.direct = 1
##             sort by #member_name
##  {
	 (*action)(2, targv, actarg);
##  }
    if (ingres_errno) return(mr_errcode);

    targv[0] = "LIST";
##  repeat retrieve (member_name = list.name)
##             where m.#list_id = @list_id and m.#member_type = "LIST"
##                   and m.#member_id = list.#list_id and m.direct = 1
##             sort by #member_name
##  {
	 (*action)(2, targv, actarg);
##  }
    if (ingres_errno) return(mr_errcode);

    targv[0] = "STRING";
##  repeat retrieve (member_name = strings.string)
##             where m.#list_id = @list_id and m.#member_type = "STRING"
##                   and m.#member_id = strings.string_id and m.direct = 1
##             sort by #member_name
##  {
	 (*action)(2, targv, actarg);
##  }
    if (ingres_errno) return(mr_errcode);

    targv[0] = "KERBEROS";
##  repeat retrieve (member_name = strings.string)
##             where m.#list_id = @list_id and m.#member_type = "KERBEROS"
##                   and m.#member_id = strings.string_id and m.direct = 1
##             sort by #member_name
##  {
	 (*action)(2, targv, actarg);
##  }
    if (ingres_errno) return(mr_errcode);

    return(MR_SUCCESS);
}


/* count_members_of_list: this is a simple query, but it cannot be done
 * through the dispatch table.
 */

int count_members_of_list(q, argv, cl, action, actarg)
    struct query *q;
    char *argv[];
    client *cl;
    int (*action)();
    int actarg;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int  list, ct = 0;
    EXEC SQL END DECLARE SECTION;
    char *rargv[1], countbuf[5];

    list = *(int *)argv[0];
    rargv[0] = countbuf;
##  repeat retrieve (ct = count(imembers.list_id
##				where imembers.list_id = @list and
##				      imembers.direct = 1))
    if (ingres_errno) return(mr_errcode);
    sprintf(countbuf, "%d", ct);
    (*action)(1, rargv, actarg);
    return(MR_SUCCESS);
}


/* qualified_get_server: passed "TRUE", "FALSE", or "DONTCARE" for each of
 * the three flags associated with each service.  It will return the name of
 * each service that meets the quailifications.  It does this by building a
 * where clause based on the arguments, then doing a retrieve.
 */

static char *sflags[3] = { "enable", "inprogress", "harderror" };

int qualified_get_server(q, argv, cl, action, actarg)
    struct query *q;
    char *argv[];
    client *cl;
    int (*action)();
    int actarg;
{
    return(qualified_get(q, argv, action, actarg, "s.name != \"\"",
			 "s", "name", sflags));
}


/* generic qualified get routine, used by qualified_get_lists,
 * qualified_get_server, and qualified_get_serverhost.
 *   Args:
 *	start - a simple where clause, must not be empty
 *	range - the name of the range variable
 *	field - the field to return
 *	flags - an array of strings, names of the flag variables
 */

int qualified_get(q, argv, action, actarg, start, range, field, flags)
    struct query *q;
    char *argv[];
    int (*action)();
    int actarg;
    char *start;
    char *range;
    char *field;
    char *flags[];
{
    EXEC SQL BEGIN DECLARE SECTION;
    char name[33], qual[256], *rvar, *rtbl, *rfield;
    int rowcount, i;
    char stmt_2_str[256];
    EXEC SQL END DECLARE SECTION;
    char *rargv[1], buf[32];

    EXEC SQL DECLARE stmt_2 STATEMENT;
    EXEC SQL DECLARE r9_cursor CURSOR FOR stmt_2;

    strcpy(qual, start);
    for (i = 0; i < q->argc; i++) {
	if (!strcmp(argv[i], "TRUE")) {
	    sprintf(buf, " and %s.%s != 0", range, flags[i]);
	    (void) strcat(qual, buf);
	} else if (!strcmp(argv[i], "FALSE")) {
	    sprintf(buf, " and %s.%s = 0", range, flags[i]);
	    (void) strcat(qual, buf);
	}
    }
      
    rargv[0] = name;
    rvar = range;
    rtbl = q->rtable;
    rfield = field;

    sprintf( stmt_2_str, "SELECT %s FROM RTBL R WHERE %s",
             R.rfield, qual );

    EXEC SQL PREPARE stmt_2 FROM :stmt_2_str;
    EXEC SQL DESCRIBE stnt_2 INTO SQLDA;

    EXEC SQL OPEN r9_cursor;
    while (1) {
      EXEC SQL FETCH r9_cursor INTO :name;
      if (sqlca.sqlcode != 0) break;
	(*action)(1, rargv, actarg);
    }
    EXEC SQL CLOSE r9_cursor;
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode == 100) return(MR_NO_MATCH);
    return(MR_SUCCESS);
}


/* qualified_get_serverhost: passed "TRUE", "FALSE", or "DONTCARE" for each of
 * the five flags associated with each serverhost.  It will return the name of
 * each service and host that meets the quailifications.  It does this by 
 * building a where clause based on the arguments, then doing a retrieve.
 */

static char *shflags[6] = { "service", "enable", "override", "success",
			    "inprogress", "hosterror" };

int qualified_get_serverhost(q, argv, cl, action, actarg)
    struct query *q;
    char *argv[];
    client *cl;
    int (*action)();
    int actarg;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char sname[33], mname[33], qual[256];
    int rowcount, i;
    char stmt_3_str[256];
    EXEC SQL END DECLARE SECTION;
    char *rargv[2], buf[32];

    EXEC SQL DECLARE stmt_3 STATEMENT;
    EXEC SQL DECLARE s9_cursor CURSOR FOR stmt_3;

    sprintf(qual, "machine.mach_id = sh.mach_id and sh.service = uppercase(\"%s\")",
	    argv[0]);
    for (i = 1; i < q->argc; i++) {
	if (!strcmp(argv[i], "TRUE")) {
	    sprintf(buf, " and sh.%s != 0", shflags[i]);
	    strcat(qual, buf);
	} else if (!strcmp(argv[i], "FALSE")) {
	    sprintf(buf, " and sh.%s = 0", shflags[i]);
	    strcat(qual, buf);
	}
    }
      
    rargv[0] = sname;
    rargv[1] = mname;
    sprintf( stmt_3_str, 
             "SELECT S.service, M.name FROM SERVERHOSTS S, MACHINE M WHERE %s",
             qual );
    EXEC SQL PREPARE stmt_3 FROM :stmt_3_str;
    EXEC SQL DESCRIBE stnt_3 INTO SQLDA;

    EXEC SQL OPEN s9_cursor;
    while (1) {
      EXEC SQL FETCH s9_cursor INTO :sname, :mname;
      if (sqlca.sqlcode != 0) break;
	(*action)(2, rargv, actarg);
    }
    EXEC SQL CLOSE s9_cursor;
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode == 100) return(MR_NO_MATCH);
    return(MR_SUCCESS);
}


/* register_user - change user's login name and allocate a pobox, group,
 * filesystem, and quota for them.  The user's status must start out as 0,
 * and is left as 2.  Arguments are: user's UID, new login name, and user's
 * type for filesystem allocation (MR_FS_STUDENT, MR_FS_FACULTY, 
 * MR_FS_STAFF, MR_FS_MISC).
 */

register_user(q, argv, cl)
    struct query *q;
    char **argv;
    client *cl;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *login, dir[65], *entity, *directory, machname[33];
    int who, rowcount, mid, uid, users_id, flag, utype, nid, list_id, quota;
    int size, alloc, pid, m_id;
    EXEC SQL END DECLARE SECTION;
    char buffer[256], *aargv[3];
    int maxsize;

    entity = cl->entity;
    who = cl->client_id;

    uid = atoi(argv[0]);
    login = argv[1];
    utype = atoi(argv[2]);

##  range of u is users
##  range of l is list
##  range of sh is serverhosts
##  range of n is nfsphys
##  range of m is machine

    /* find user */
    EXEC SQL DECLARE u_cursor CURSOR FOR
     SELECT U.users_id
     FROM USERS U
     WHERE U.uid = :uid AND (U.status = 0 OR U.status = 5 OR U.status = 6);
    EXEC SQL OPEN u_cursor;
    while (1) {
        EXEC SQL FETCH u_cursor INTO :users_id;
        if (sqlca.sqlcode != 0) break;
    }
    if (sqlca.sqlcode == 100) return(MR_NO_MATCH);
    if (sqlca.sqlerrd[2] > 1) return(MR_NOT_UNIQUE);

    /* check new login name */
##  repeat retrieve (flag = any(u.#login where u.#login = @login and
##				u.#users_id != users_id))
    if (ingres_errno) return(mr_errcode);
    if (flag) return(MR_IN_USE);
##  repeat retrieve (flag = any(l.#name where l.#name = @login))
    if (ingres_errno) return(mr_errcode);
    if (flag) return(MR_IN_USE);
##  repeat retrieve (flag = any(filesys.#label where filesys.#label = @login))
    if (ingres_errno) return(mr_errcode);
    if (flag) return(MR_IN_USE);
    com_err(whoami, 0, "new login name OK");

    /* choose place for pobox, put in mid */

##  repeat retrieve (mid = sh.mach_id, machname = m.name)
##    where sh.service = "POP" and m.mach_id = sh.mach_id and
##	sh.value2 - sh.value1 = max(sh.value2-sh.value1 where sh.service="POP")
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode == 100) return(MR_NO_POBOX);

    /* change login name, set pobox */
    sprintf(buffer, "u.users_id = %d", users_id);
    incremental_before("users", buffer, 0);
##  repeat replace u (#login = @login, status = 2, modtime = "now",
##		      modby = @who, modwith = @entity, potype="POP",
##		      pop_id = @mid, pmodtime="now", pmodby=@who,
##		      pmodwith=@entity)
##	where u.#users_id = @users_id
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_INTERNAL);
    set_pop_usage(mid, 1);
    com_err(whoami, 0, "set login name to %s and pobox to %s", login,
	    strtrim(machname));
    incremental_after("users", buffer, 0);

    /* create group list */
    if (set_next_object_id("gid", "list"))
      return(MR_NO_ID);
    if (set_next_object_id("list_id", "list"))
      return(MR_NO_ID);

    EXEC SQL DECLARE v_cursor CURSOR FOR
         SELECT V.value
         FROM values_tbl V
         WHERE V.name = "list_id";
    EXEC SQL OPEN v_cursor;
    while (1) {
        EXEC SQL FETCH v_cursor INTO :list_id;
        if (sqlca.sqlcode != 0) break;
    }
    EXEC SQL CLOSE v_cursor;

    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_INTERNAL);
    incremental_clear_before();
##  repeat append list (name = @login, #list_id = @list_id, active = 1,
##			public = 0, hidden = 0, maillist = 0, group = 1,
##			#gid = values_tbl.value, desc = "User Group",
##			acl_type = "USER", acl_id = @users_id, modtime = "now",
##			modby = @who, modwith = @entity)
##	where values_tbl.name = "gid"
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_INTERNAL);
    sprintf(buffer, "l.list_id = %d", list_id);
    incremental_after("list", buffer, 0);
    aargv[0] = (char *) list_id;
    aargv[1] = "USER";
    aargv[2] = (char *) users_id;
    incremental_clear_before();
##  repeat append imembers (#list_id = @list_id, member_type = "USER",
##			   member_id = @users_id, ref_count = 1, direct = 1)
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_INTERNAL);

    incremental_after("members", 0, aargv);
    com_err(whoami, 0, "group list created");

    /* decide where to put filesystem */
    maxsize = 0;
    directory = NULL;
##  repeat retrieve (mid = n.mach_id, dir = trim(n.#dir), nid = n.nfsphys_id,
##		     flag = n.status, size = n.#size, alloc = n.allocated) {
	if ((flag & utype) && (size != 0) && (size - alloc > maxsize)) {
	    maxsize = size - alloc;
	    if (directory)
	      free(directory);
	    directory = strsave(dir);
	    pid = nid;
	    m_id = mid;
	}
##  }
    if (ingres_errno) return(mr_errcode);
    if (maxsize == 0)
      return(MR_NO_FILESYS);

    /* create filesystem */
    if (set_next_object_id("filsys_id", "filesys"))
      return(MR_NO_ID);
    incremental_clear_before();	
##  repeat append filesys (filsys_id = values_tbl.value, phys_id = @pid,
##			   label = @login, type = "NFS", mach_id = @m_id,
##			   name = @directory + "/" + @login,
##			   mount = "/mit/" + @login,
##			   access = "w", comments = "User Locker",
##			   owner = @users_id, owners = @list_id, createflg = 1,
##			   lockertype = "HOMEDIR", modtime = "now",
##			   modby = @who, modwith = @entity)
##	where values_tbl.name = "filsys_id"
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_INTERNAL);
    incremental_after("filesys", 
	  "fs.filsys_id = values_tbl.value and values_tbl.name = \"filsys_id\"",
		      0);
    com_err(whoami, 0, "filesys created on mach %d in %s/%s", m_id,
	    directory, login);

    /* set quota */
##  repeat retrieve (quota = values_tbl.value) where values_tbl.name = "def_quota"
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_NO_QUOTA);
    incremental_clear_before();
##  repeat append #quota (entity_id = @users_id, filsys_id = values_tbl.value,
##			  type = "USER",
##			  #quota = @quota, phys_id = @pid, modtime = "now",
##			  modby = @who, modwith = @entity)
##	where values_tbl.name = "filsys_id"
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_INTERNAL);
##  repeat replace nfsphys (allocated = nfsphys.allocated + @quota)
##	where nfsphys.nfsphys_id = filesys.#phys_id and
##	      filesys.filsys_id = values_tbl.value and values_tbl.name = "filsys_id"
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_INTERNAL);
    aargv[0] = login;
    aargv[1] = "USER";
    aargv[2] = login;
    sprintf(buffer, "q.entity_id = %d and q.filsys_id = values_tbl.value and q.type = \"USER\" and values_tbl.name = \"filsys_id\"", users_id);
    incremental_after("quota", buffer, aargv);
    com_err(whoami, 0, "quota of %d assigned", quota);
    if (ingres_errno) return(mr_errcode);

    cache_entry(login, "USER", users_id);

    EXEC SQL UPDATE tblstats
         SET updates = tblstats.updates + 1, modtime = "now"
         WHERE table_name = "users"

    EXEC SQL UPDATE tblstats
         SET appends = tblstats.appends + 1, modtime = "now"
         WHERE table_name = "list" OR table_name = "filesys" 
               OR table_name = "quota";

    if (ingres_errno) return(mr_errcode);
    return(MR_SUCCESS);
}



/** set_pop_usage - incr/decr usage count for pop server in serverhosts talbe
 **
 ** Inputs:
 **   id of machine
 **   delta (will be +/- 1)
 **
 ** Description:
 **   - incr/decr value field in serverhosts table for pop/mach_id
 **
 **/

static int set_pop_usage(id, count)
int id;
int count;
{
    EXEC SQL BEGIN DECLARE SECTION;
    int mach_id = id;
    int n = count;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL UPDATE serverhosts
         SET value1 = value1 + :n
         WHERE service = "POP" AND mach_id = :mach_id;

    if (ingres_errno) return(mr_errcode);
    return(MR_SUCCESS);
}



/* Validation Routines */

validate_row(q, argv, v)
    register struct query *q;
    char *argv[];
    register struct validate *v;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *rvar;
    char *tbl;
    char *name;
    char qual[128];
    int rowcount;
    EXEC SQL END DECLARE SECTION;

    /* build where clause */
    build_qual(v->qual, v->argc, argv, qual);

    /* setup ingres variables */
    rvar = q->rvar;
    tbl = q->rtable;
    name = v->field;

    if (log_flags & LOG_VALID)
	/* tell the logfile what we're doing */
	com_err(whoami, 0, "validating row: %s", qual);
    
    /* look for the record */
##  range of rvar is tbl
##  retrieve (rowcount = count(rvar.name where qual))
    if (ingres_errno) return(mr_errcode);
    if (rowcount == 0) return(MR_NO_MATCH);
    if (rowcount > 1) return(MR_NOT_UNIQUE);
    return(MR_EXISTS);
}

validate_fields(q, argv, vo, n)
    struct query *q;
    register char *argv[];
    register struct valobj *vo;
    register int n;
{
    register int status;

    while (--n >= 0) {
	switch (vo->type) {
	case V_NAME:
	    if (log_flags & LOG_VALID)
		com_err(whoami, 0, "validating %s in %s: %s", 
		    vo->namefield, vo->table, argv[vo->index]);
	    status = validate_name(argv, vo);
	    break;

	case V_ID:
	    if (log_flags & LOG_VALID)
		com_err(whoami, 0, "validating %s in %s: %s", 
		    vo->idfield, vo->table, argv[vo->index]);
	    status = validate_id(argv, vo);
	    break;

	case V_DATE:
	    if (log_flags & LOG_VALID)
		com_err(whoami, 0, "validating date: %s", argv[vo->index]);
	    status = validate_date(argv, vo);
	    break;

	case V_TYPE:
	    if (log_flags & LOG_VALID)
		com_err(whoami, 0, "validating %s type: %s",
		    vo->table, argv[vo->index]);
	    status = validate_type(argv, vo);
	    break;

	case V_TYPEDATA:
	    if (log_flags & LOG_VALID)
		com_err(whoami, 0, "validating typed data (%s): %s",
		    argv[vo->index - 1], argv[vo->index]);
	    status = validate_typedata(q, argv, vo);
	    break;

	case V_RENAME:
	    if (log_flags & LOG_VALID)
	        com_err(whoami, 0, "validating rename %s in %s",
			argv[vo->index], vo->table);
	    status = validate_rename(argv, vo);
	    break;

	case V_CHAR:
	    if (log_flags & LOG_VALID)
	      com_err(whoami, 0, "validating chars: %s", argv[vo->index]);
	    status = validate_chars(argv[vo->index]);
	    break;

	case V_SORT:
	    status = MR_EXISTS;
	    break;

	case V_LOCK:
	    status = lock_table(vo);
	    break;
	}

	if (status != MR_EXISTS) return(status);
	vo++;
    }

    if (ingres_errno) return(mr_errcode);
    return(MR_SUCCESS);
}


/* validate_chars: verify that there are no illegal characters in
 * the string.  Legal characters are printing chars other than 
 * ", *, ?, \, [ and ].
 */
static int illegalchars[] = {
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* ^@ - ^O */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* ^P - ^_ */
    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, /* SPACE - / */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, /* 0 - ? */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* @ - O */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, /* P - _ */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* ` - o */
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, /* p - ^? */
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
};

validate_chars(s)
register char *s;
{
    while (*s)
      if (illegalchars[*s++])
	return(MR_BAD_CHAR);
    return(MR_EXISTS);
}


validate_id(argv, vo)
    char *argv[];
    register struct valobj *vo;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *name;
    char *tbl;
    char *namefield;
    char *idfield;
    int id, rowcount;
    EXEC SQL END DECLARE SECTION;
    int status;
    register char *c;


    name = argv[vo->index];
    tbl = vo->table;
    namefield = vo->namefield;
    idfield = vo->idfield;

    if ((!strcmp(tbl, "users") && !strcmp(namefield, "login")) ||
	!strcmp(tbl, "machine") ||
	!strcmp(tbl, "filesys") ||
	!strcmp(tbl, "list") ||
	!strcmp(tbl, "cluster") ||
	!strcmp(tbl, "string")) {
	if (!strcmp(tbl, "machine"))
	  for (c = name; *c; c++) if (islower(*c)) *c = toupper(*c);
	status = name_to_id(name, tbl, &id);
	if (status == 0) {
	    *(int *)argv[vo->index] = id;
	    return(MR_EXISTS);
	} else if (status == MR_NO_MATCH || status == MR_NOT_UNIQUE)
	  return(vo->error);
	else
	  return(status);
    }

    if (!strcmp(namefield, "uid")) {
##    retrieve (id = tbl.idfield) where tbl.namefield = int4(name)
      if (ingres_errno) return(mr_errcode);
    } else {
##    retrieve (id = table.idfield) where table.namefield = name
      if (ingres_errno) return(mr_errcode);
    }
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(vo->error);
    *(int *)argv[vo->index] = id;
    return(MR_EXISTS);
}

validate_name(argv, vo)
    char *argv[];
    register struct valobj *vo;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *name;
    char *tbl;
    char *namefield;
    int rowcount;
    EXEC SQL END DECLARE SECTION;
    register char *c;

    name = argv[vo->index];
    tbl = vo->table;
    namefield = vo->namefield;
    if (!strcmp(tbl, "servers") && !strcmp(namefield, "name")) {
	for (c = name; *c; c++)
	  if (islower(*c))
	    *c = toupper(*c);
    }
##  retrieve (rowcount = countu(tbl.namefield 
##            where tbl.namefield = name))
    if (ingres_errno) return(mr_errcode);
    return ((rowcount == 1) ? MR_EXISTS : vo->error);
}

validate_date(argv, vo)
    char *argv[];
    struct valobj *vo;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *idate;
    double dd;
    int errorno;
    EXEC SQL END DECLARE SECTION;

    idate = argv[vo->index];

##  retrieve (dd = interval("years", date(idate) - date("today")))
    if (sqlca.sqlcode < 0 || dd > 5.0) return(MR_DATE);
    return(MR_EXISTS);
}


validate_rename(argv, vo)
char *argv[];
struct valobj *vo;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *name, *tbl, *namefield, *idfield;
    int id;
    EXEC SQL END DECLARE SECTION;
    int status;
    register char *c;

    c = name = argv[vo->index];
    while (*c)
      if (illegalchars[*c++])
	return(MR_BAD_CHAR);
    tbl = vo->table;
    /* minor kludge to upcasify machine names */
    if (!strcmp(tbl, "machine"))
	for (c = name; *c; c++) if (islower(*c)) *c = toupper(*c);
    namefield = vo->namefield;
    idfield = vo->idfield;
    id = -1;
    if (idfield == 0) {
	if (!strcmp(argv[vo->index], argv[vo->index - 1]))
	  return(MR_EXISTS);
##	retrieve (id = any(tbl.namefield where tbl.namefield = name))
	if (ingres_errno) return(mr_errcode);
	if (id)
	  return(vo->error);
	else
	  return(MR_EXISTS);
    }
    status = name_to_id(name, tbl, &id);
    if (status == MR_NO_MATCH || id == *(int *)argv[vo->index - 1])
      return(MR_EXISTS);
    else
      return(vo->error);
}


validate_type(argv, vo)
    char *argv[];
    register struct valobj *vo;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *typename;
    char *value;
    int exist;
    EXEC SQL END DECLARE SECTION;
    register char *c;

    typename = vo->table;
    c = value = argv[vo->index];
    while (*c)
      if (illegalchars[*c++])
	return(MR_BAD_CHAR);

    /* uppercase type fields */
    for (c = value; *c; c++) if (islower(*c)) *c = toupper(*c);

##  repeat retrieve (exist = any(alias.trans where alias.name = @typename and
##				  alias.type = "TYPE" and alias.trans = @value))
    if (ingres_errno) return(mr_errcode);
    return (exist ? MR_EXISTS : vo->error);
}

/* validate member or type-specific data field */

validate_typedata(q, argv, vo)
    register struct query *q;
    register char *argv[];
    register struct valobj *vo;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *name;
    char *field_type;
    char data_type[129];
    int id, rowcount;
    EXEC SQL END DECLARE SECTION;

    int status;
    char *index();
    register char *c;

    /* get named object */
    name = argv[vo->index];

    /* get field type string (known to be at index-1) */
    field_type = argv[vo->index-1];

    /* get corresponding data type associated with field type name */
##  repeat retrieve (data_type = alias.trans) 
##         where alias.#name = @field_type and alias.type = "TYPEDATA"
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(MR_TYPE);

    /* now retrieve the record id corresponding to the named object */
    if (index(data_type, ' '))
	*index(data_type, ' ') = 0;
    if (!strcmp(data_type, "user")) {
	/* USER */
	status = name_to_id(name, data_type, &id);
	if (status && (status == MR_NO_MATCH || status == MR_NOT_UNIQUE))
	  return(MR_USER);
	if (status) return(status);
    } else if (!strcmp(data_type, "list")) {
	/* LIST */
	status = name_to_id(name, data_type, &id);
	if (status && status == MR_NOT_UNIQUE)
	  return(MR_LIST);
	if (status == MR_NO_MATCH) {
	    /* if idfield is non-zero, then if argv[0] matches the string
	     * that we're trying to resolve, we should get the value of
	     * values_tbl.[idfield] for the id.
	     */
	    if (vo->idfield && !strcmp(argv[0], argv[vo->index])) {
		set_next_object_id(q->validate->object_id, q->rtable);
		name = vo->idfield;
##		repeat retrieve (id = values_tbl.value) where values_tbl.#name = @name
                if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
                  return(MR_LIST);
	    } else
	      return(MR_LIST);
	} else if (status) return(status);
    } else if (!strcmp(data_type, "machine")) {
	/* MACHINE */
	for (c = name; *c; c++) if (islower(*c)) *c = toupper(*c);
	status = name_to_id(name, data_type, &id);
	if (status && (status == MR_NO_MATCH || status == MR_NOT_UNIQUE))
	  return(MR_MACHINE);
	if (status) return(status);
    } else if (!strcmp(data_type, "string")) {
	/* STRING */
	status = name_to_id(name, data_type, &id);
	if (status && status == MR_NOT_UNIQUE)
	  return(MR_STRING);
	if (status == MR_NO_MATCH) {
	    if (q->type != APPEND && q->type != UPDATE) return(MR_STRING);
##          retrieve (id = values_tbl.value) where values_tbl.#name = "strings_id"
	    id++;
##          replace values_tbl.(value = id) where values_tbl.#name = "strings_id"
##	    append to strings (string_id = id, string = name)
	} else if (status) return(status);
    } else if (!strcmp(data_type, "none")) {
	id = 0;
    } else {
	return(MR_TYPE);
    }

    /* now set value in argv */
    *(int *)argv[vo->index] = id;
    
    return (MR_EXISTS);
}


/* Lock the table named by the validation object */

lock_table(vo)
struct valobj *vo;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char *tbl, *idfield;
    int rowcount;
    EXEC SQL END DECLARE SECTION;

    tbl = vo->table;
    idfield = vo->idfield;
##  replace tbl (modtime = "now") where tbl.idfield = 0
    if (ingres_errno) return(mr_errcode);
    if (sqlca.sqlcode < 0 || sqlca.sqlerrd[2] != 1)
      return(vo->error);
    else
      return(MR_EXISTS);
}


/* Check the database at startup time.  For now this just resets the
 * inprogress flags that the DCM uses.
 */

sanity_check_database()
{
}
