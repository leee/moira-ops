/* $Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/dbck/phase1.pc,v 1.1 1997-01-29 23:13:13 danw Exp $
 *
 *  (c) Copyright 1988 by the Massachusetts Institute of Technology.
 *  For copying and distribution information, please see the file
 *  <mit-copyright.h>.
 */

#include <mit-copyright.h>
#include <moira.h>
#include <stdio.h>
#include "dbck.h"
EXEC SQL INCLUDE sqlca;

static char phase1_qc_rcsid[] = "$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/dbck/phase1.pc,v 1.1 1997-01-29 23:13:13 danw Exp $";

EXEC SQL WHENEVER SQLERROR DO dbmserr();

show_user_id(u)
struct user *u;
{
    printf("User %s (%s, status %d) has duplicate ID\n",
	   u->login, u->fullname, u->status);
    return(0);
}

handle_duplicate_logins(sq)
struct save_queue *sq;
{
    struct user *u, *uu, *tmp;

    uu = (struct user *)0;
    if(sq_get_data(sq,&uu)) {
      while (sq_get_data(sq, &u)) {
	if (!strcmp(u->login, uu->login)) {
	    if (uu->status == 1 || u->status == 0) {
		tmp = u;
		u = uu;
		uu = tmp;
	    }
	    printf("User %s (%s, status %d) and\n",
		   u->login, u->fullname, u->status);
	    printf("User %s (%s, status %d) have duplicate logins\n",
		   uu->login, uu->fullname, uu->status);
	    if (!strcmp(u->fullname, uu->fullname) &&
		single_fix("Delete the second one")) {
		single_delete("users", "users_id", uu->users_id);
	    } else if (single_fix("Unregister the second one"))
	      {
		EXEC SQL BEGIN DECLARE SECTION; 
    		int id = uu->users_id, rowcount;
		EXEC SQL END DECLARE SECTION; 

		EXEC SQL UPDATE users SET login = '#' || CHAR(users.unix_uid),
		    status=0 WHERE users_id = :id;
		rowcount = sqlca.sqlerrd[2];
    		if (rowcount > 0)
		  printf("%d entr%s fixed\n", rowcount, rowcount==1?"y":"ies");
		else
		  printf("Not fixed\n");
		modified("users");
	      }
	} else {
	    uu = u;
	}
      }
    }
}

fix_user_id(u)
struct user *u;
{
    u->users_id = generic_fix_id("users", "users_id", "login",
				 u->users_id, u->login);
}


cant_fix(id)
int id;
{
    printf("Sorry, don't know how to fix that\n");
}

show_mach_id(m)
struct machine *m;
{
    printf("Machine %s has duplicate ID %d\n", m->name, m->mach_id);
    return(0);
}

show_mach_name(m)
struct machine *m;
{
    printf("Machine %s (%d) has duplicate name\n", m->name, m->mach_id);
    return(0);
}

fix_mach_id(m)
struct machine *m;
{
    m->mach_id = generic_fix_id("machine", "mach_id", "name",
				m->mach_id, m->name);
}

show_clu_id(c)
struct cluster *c;
{
    printf("Cluster %s has duplicate ID %d\n", c->name, c->clu_id);
    return(0);
}

show_clu_name(c)
struct cluster *c;
{
    printf("Cluster %s (%d) has duplicate name\n", c->name, c->clu_id);
    return(0);
}

fix_clu_id(c)
struct cluster *c;
{
    c->clu_id = generic_fix_id("cluster", "clu_id", "name", c->clu_id, c->name);
}

show_list_id(l)
struct list *l;
{
    printf("List %s has duplicate ID %d\n", l->name, l->list_id);
    return(0);
}

show_list_name(l)
struct list *l;
{
    printf("List %s (%d) has duplicate name\n", l->name, l->list_id);
    return(0);
}

fix_list_id(l)
struct list *l;
{
    l->list_id = generic_fix_id("list", "list_id", "name", l->list_id, l->name);
}

show_fs_id(f)
struct filesys *f;
{
    printf("Filesys %s has duplicate ID %d\n", f->name, f->filsys_id);
    return(0);
}

fix_fs_id(f)
struct filesys *f;
{
    f->filsys_id = generic_fix_id("filesys", "filsys_id", "label",
				  f->filsys_id, f->name);
}


show_np_id(n)
struct nfsphys *n;
{
    printf("NfsPhys %s:%s has duplicate ID %d\n",
	   ((struct machine *)hash_lookup(machines, n->mach_id))->name,
	   n->dir, n->nfsphys_id);
    return(0);
}

fix_np_id(n)
struct nfsphys *n;
{
    n->nfsphys_id = generic_fix_id("nfsphys", "nfsphys_id", "dir",
				   n->nfsphys_id, n->dir);
}

show_str_id(s)
struct string *s;
{
    printf("String %s has duplicate ID %d\n", s->name, s->string_id);
    return(0);
}

print_str_id(id)
     int id;
{
  printf("String %d is a duplicate\n", id);
  return(0);
}

print_dup_map(key, data, hint)
	int key;
	int data;
	char *hint;
{
	printf("String %d is a duplicate of string %d\n", key, data);

}

phase1()
{
    EXEC SQL BEGIN DECLARE SECTION; 
    char name[81], name1[81], last[17], first[17], buf[257];
    int id, id1, id2, id3, aid, aid2, status;
    int sid, sid2, sid3, sid4, sid5;
    EXEC SQL END DECLARE SECTION; 
    int i, q, retval, tmp;
    struct save_queue *sq;
    struct user *u;
    struct machine *m;
    struct subnet *sn;
    struct list *l;
    struct cluster *c;
    struct string *s;
    struct filesys *f;
    struct nfsphys *n;

    printf("Phase 1 - Looking for duplicates\n");

    /* self-join strings table on "string" to get duplicate strings, then
       build a duplicates table to merge them. */

    dprintf("Looking for duplicate strings...\n");
    string_dups = create_hash( 100 );
    if(!string_dups) out_of_mem("storing duplicate strings");
    
    EXEC SQL DECLARE csr116 CURSOR FOR
      SELECT s1.string_id, s2.string_id FROM strings s1, strings s2
	where s1.string = s2.string and s1.string_id < s2.string_id;
    EXEC SQL OPEN csr116;
    /*  The SELECT gives us two columns, both with non-negative integers.
     *  The number in the left column is always the smaller of the two,
     *  and each row includes string IDs for identical strings.  We use
     *  them to make a mapping from id-to-delete to id-to-keep for all
     *	superflous IDs.
     */
    q=0;
    while(1) {
	EXEC SQL FETCH csr116 INTO :id1, :id2;
	if (sqlca.sqlcode != 0) break;
	q++;
	/*  If id2 is already stored, skip this row. */
	i = int_hash_lookup( string_dups, id2 );
	if( i > 0 ) { continue; }
	/*  Follow the chain of id1 equivalent IDs back to the lowest one. */
	id=id1;
	while((tmp=int_hash_lookup(string_dups, id))>0)
	  id=tmp;
	int_hash_store( string_dups, id2, id );
    }
    EXEC SQL CLOSE csr116;
    dprintf("found %d duplicates\n", q);
    int_hash_step(string_dups, print_dup_map, NULL);
    /* We don't want to delete the duplicates now because if the dbck
       is cancelled, a LOT of state will be lost. So, we'll just let
       them not get marked as used and then phase3 will clean them up */

    dprintf("Loading strings...\n");
    sq = sq_create();
    strings = create_hash(75000);
    if(!sq || !strings) out_of_mem("loading strings");

    EXEC SQL DECLARE csr101 CURSOR FOR
      SELECT string_id, string FROM strings ORDER BY string_id;
    EXEC SQL OPEN csr101;
    q=0;
    while(1) {
	EXEC SQL FETCH csr101 INTO :id, :buf;
	if (sqlca.sqlcode != 0) break;
	q++;
	s = (struct string *) malloc(sizeof(struct string));
	if (s == NULL)
	  out_of_mem("storing strings");
	s->name = strsave(strtrim(buf));
	s->string_id = id;
	s->refc = 0;
	retval = hash_store(strings, id, s);
	if ( retval == -1 ) {
	  out_of_mem("storing strings in hash table");
	} else if ( retval == 1 ) { /* duplicate string_id*/
	  sq_save_data(sq, hash_lookup(strings, id));
	  sq_save_data(sq, s);
	}
    }
    EXEC SQL CLOSE csr101;
    /* I'm not at all convinced this will work, so...
       generic_delete(sq, show_str_id, "strings", "string_id", 0);
    */
    string_check(0);

    printf("Loaded %d strings\n", q);

    dprintf("Loading users...\n");
    sq = sq_create();
    users = create_hash(30000);
    if(!sq || !users) out_of_mem("loading users");

    EXEC SQL DECLARE csr102 CURSOR FOR 
      SELECT users_id, login, last, first, status, potype, pop_id, box_id,
	  modby, fmodby, pmodby, comments, sigwho FROM users
	ORDER BY users_id;
    EXEC SQL OPEN csr102;
    while(1) {
	EXEC SQL FETCH csr102 INTO :id, :name, :last, :first, :status,
            :buf, :id2, :id3, :sid, :sid2, :sid3, :sid4, :sid5;
	if (sqlca.sqlcode != 0) break;

    	u = (struct user *) malloc(sizeof(struct user));
	if (u == NULL)
	  out_of_mem("storing users");
	strcpy(u->login, strtrim(name));
	u->potype = buf[0];
	sprintf(buf, "%s, %s", strtrim(last), strtrim(first));
	u->fullname = strsave(buf);
	u->status = status;
	u->users_id = id;
	u->modby = sid;
	u->fmodby = sid2;
	u->pmodby = sid3;
	u->comment = sid4;
	u->sigwho = sid5;
	switch (u->potype) {
	case 'P':
	    u->pobox_id = id2;
	    break;
	case 'S':
	    /*  If potype is SMTP, box_id is a string_id for the strings tbl */
	    u->pobox_id = id3;
	    break;
	default:
	    u->pobox_id = 0;
	}
	retval = hash_store(users, id, u);
	if ( retval == -1 ) {
	    out_of_mem("storing users in hash table");
	} else if ( retval == 1 ) {
	    sq_save_data(sq, hash_lookup(users, id));
	    sq_save_data(sq, u);
	}
    }
    EXEC SQL CLOSE csr102; 

    generic_fix(sq, show_user_id, "Change ID", fix_user_id, 0);

    if (!fast) {
	sq = sq_create();
	if(!sq) out_of_mem("finding duplicate logins");

	EXEC SQL DECLARE csr103 CURSOR FOR 
	    SELECT u1.users_id FROM users u1, users u2
	    WHERE u1.login = u2.login and u1.rowid != u2.rowid;
	EXEC SQL OPEN csr103;
	while(1) {
	    EXEC SQL FETCH csr103 INTO :id;
	    if (sqlca.sqlcode != 0) break;
	    sq_save_data(sq, hash_lookup(users, id));
	}
	EXEC SQL CLOSE csr103; 
	handle_duplicate_logins(sq);
    }

    if (!fast) {
	dprintf("Scanning krbmap...\n");

	EXEC SQL DECLARE csr113 CURSOR FOR
	    SELECT k1.users_id FROM krbmap k1, krbmap k2
		WHERE k1.users_id = k2.users_id AND k1.rowid != k2.rowid;
	EXEC SQL OPEN csr113;
	while(1) {
	    EXEC SQL FETCH csr113 INTO :id;
	    if (sqlca.sqlcode != 0) break;

	    printf("User %d is in the krbmap more than once!\n", id);
	    printf("Not fixing this error\n");
	}
	EXEC SQL CLOSE csr113; 

	EXEC SQL DECLARE csr114 CURSOR FOR
	    SELECT k1.string_id FROM krbmap k1, krbmap k2
		WHERE k1.string_id = k2.string_id AND k1.rowid != k2.rowid;
	EXEC SQL OPEN csr114;
	while(1) {
	    EXEC SQL FETCH csr114 INTO :id;
	    if (sqlca.sqlcode != 0) break; 

	    printf("Principal %d is in the krbmap more than once!\n", id);
	    printf("Not fixing this error\n");
	}
	EXEC SQL CLOSE csr114; 
    }

    dprintf("Loading machines...\n");
    sq = sq_create();
    machines = create_hash(20000);
    if(!sq || !machines) out_of_mem("loading machines");

    EXEC SQL DECLARE csr104 CURSOR FOR
	SELECT mach_id, name, snet_id, owner_type, owner_id,
      		acomment, ocomment, creator, modby
	FROM machine ORDER BY mach_id;
    EXEC SQL OPEN csr104;
    while(1) {
	EXEC SQL FETCH csr104 INTO :id, :name, :id2, :buf, :id3, :sid2,
		:sid3, :sid4, :sid;
	if (sqlca.sqlcode != 0) break; 

    	m = (struct machine *) malloc(sizeof(struct machine));
	if (m == NULL)
	  out_of_mem("storing machines");
	strcpy(m->name, strtrim(name));
	m->owner_type = buf[0];
	m->owner_id = id3;
	m->snet_id = id2;
	m->mach_id = id;
	m->clucount = 0;
	m->acomment=sid2;
	m->ocomment=sid3;
	m->creator=sid4;
	m->modby=sid;
	retval = hash_store(machines, id, m);
	if ( retval == -1 ) {
	    out_of_mem("storing machines in hash table");
	} else if ( retval == 1 ) {
	    sq_save_data(sq, hash_lookup(machines, id));
	    sq_save_data(sq, m);
	}
    }
    EXEC SQL CLOSE csr104; 
    generic_fix(sq, show_mach_id, "Change ID", fix_mach_id, 0);

    if (!fast) {
	sq = sq_create();
	if(!sq) out_of_mem("looking for duplicate machine names");

	EXEC SQL DECLARE csr105 CURSOR FOR
	    SELECT m1.mach_id FROM machine m1, machine m2
		WHERE m1.name = m2.name AND m1.rowid != m2.rowid;
	EXEC SQL OPEN csr105;
	while(1) {
	    EXEC SQL FETCH csr105 INTO :id;
	    if (sqlca.sqlcode != 0) break; 

	    sq_save_data(sq, hash_lookup(machines, id));
	}
	EXEC SQL CLOSE csr105; 
	generic_fix(sq, show_mach_name, "Change name", cant_fix, 0);

	EXEC SQL DECLARE csr_hal1 CURSOR FOR
	  SELECT h1.name, m1.mach_id, m2.mach_id
	  FROM hostalias h1, machine m1, hostalias h2, machine m2
	  WHERE h1.name=h2.name AND h1.mach_id!=h2.mach_id
	  AND m1.mach_id=h1.mach_id AND m2.mach_id=h2.mach_id;
	EXEC SQL OPEN csr_hal1;
	while(1) {
	  EXEC SQL FETCH csr_hal1 INTO :name, :id1, :id2;
	  if(sqlca.sqlcode!=0) break;
	  printf("Aliases for machines %d and %d have duplicate name %s\n",
		 id1, id2, strtrim(name));
	  cant_fix();
	}
	EXEC SQL CLOSE csr_hal1;

	EXEC SQL DECLARE csr_hal2 CURSOR FOR
	  SELECT h1.name, m1.mach_id, m2.mach_id
	  FROM hostalias h1, machine m1, machine m2
	  WHERE h1.name=m1.name AND h1.mach_id=m2.mach_id;
	EXEC SQL OPEN csr_hal2;
	while(1) {
	  EXEC SQL FETCH csr_hal2 INTO :name, :id1, :id2;
	  if(sqlca.sqlcode!=0) break;
	  printf("Machine %d has alias `%s' that conflicts with machine %d\n",
		 id2, strtrim(name), id1);
	  cant_fix();
	}
	EXEC SQL CLOSE csr_hal2;
    }	

    dprintf("Loading subnets...\n");
    subnets = create_hash(254);
    if(!subnets) out_of_mem("loading subnets");

    EXEC SQL DECLARE csr115 CURSOR FOR
      SELECT snet_id, name, owner_type, owner_id, modby from subnet;
    EXEC SQL OPEN csr115;
    while(1) {
	EXEC SQL FETCH csr115 INTO :id, :name, :buf, :id2, :sid;
	if (sqlca.sqlcode != 0) break;

	sn = (struct subnet *) malloc(sizeof(struct machine));
	if (sn == NULL)
	  out_of_mem("storing subnets");
	strcpy(sn->name, strtrim(name));
	sn->owner_type=buf[0];
	sn->owner_id = id2;
	sn->snet_id = id;
	sn->modby = sid;
	retval = hash_store(subnets, id, sn);
	if ( retval == -1 ) {
	    out_of_mem("storing subnets in hash table");
	} else if ( retval == 1 ) {
	    printf("Duplicate subnet ID: %d (%s)\n", id, name);
	    /* should add code to delete */
	}
    }
    EXEC SQL CLOSE csr115;

    dprintf("Loading clusters...\n");
    sq = sq_create();
    clusters = create_hash(100);
    if(!sq || !clusters) out_of_mem("loading clusters");

    EXEC SQL DECLARE csr106 CURSOR FOR
	SELECT clu_id, name, modby FROM clusters;
    EXEC SQL OPEN csr106;
    while(1) {
	EXEC SQL FETCH csr106 INTO :id, :name, :sid;
	if (sqlca.sqlcode != 0) break; 

    	c = (struct cluster *) malloc(sizeof(struct cluster));
	if (c == NULL)
	  out_of_mem("storing clusters");
	strcpy(c->name, strtrim(name));
	c->clu_id = id;
	c->modby = sid;
	retval = hash_store(clusters, id, c);
	if ( retval == -1 ) {
	    out_of_mem("storing clusters in hash table");
	} else if ( retval == 1 ) {
	    sq_save_data(sq, hash_lookup(clusters, id));
	    sq_save_data(sq, c);
	}
    }
    EXEC SQL CLOSE csr106; 
    generic_fix(sq, show_clu_id, "Change ID", fix_clu_id, 0);

    if (!fast) {
	sq = sq_create();
	if(!sq) out_of_mem("looking for duplicate cluster names");

	EXEC SQL DECLARE csr107 CURSOR FOR
	    SELECT c1.clu_id FROM clusters c1, clusters c2
		WHERE c1.name=c2.name AND c1.rowid != c2.rowid;
	EXEC SQL OPEN csr107;
	while(1) {
	    EXEC SQL FETCH csr107 INTO :id;
	    if (sqlca.sqlcode != 0) break; 

	    sq_save_data(sq, hash_lookup(clusters, id));
	}
	EXEC SQL CLOSE csr107; 
	generic_fix(sq, show_clu_name, "Change name", cant_fix, 0);
    }

    dprintf("Loading lists...\n");
    sq = sq_create();
    lists = create_hash(50000);
    if(!sq || !lists) out_of_mem("loading lists");

    EXEC SQL DECLARE csr108 CURSOR FOR
	SELECT list_id, name, acl_id, acl_type, modby  FROM list 
	ORDER BY list_id;
    EXEC SQL OPEN csr108;
    while(1) {
	EXEC SQL FETCH csr108 INTO :id, :name, :aid, :buf, :sid;
	if (sqlca.sqlcode != 0) break;
    	l = (struct list *) malloc(sizeof(struct list));
	if (l == NULL)
	  out_of_mem("storing lists");
	strcpy(l->name, strtrim(name));
	l->acl_type = buf[0];
	l->acl_id = aid;
	l->list_id = id;
	l->members = 0;
	retval = hash_store(lists, id, l);
	if ( retval == -1 ) {
	    out_of_mem("storing lists in hash table");
	} else if ( retval == 1 ) {
	    sq_save_data(sq, hash_lookup(lists, id));
	    sq_save_data(sq, l);
	}
    }
    EXEC SQL CLOSE csr108; 
    generic_fix(sq, show_list_id, "Change ID", fix_list_id, 0);

    if (!fast) {
	sq = sq_create();
	if(!sq) out_of_mem("looking for duplicate list names");

	EXEC SQL DECLARE csr109 CURSOR FOR
	    SELECT l1.list_id FROM list l1, list l2
		WHERE l1.name=l2.name AND l1.rowid != l2.rowid;
	EXEC SQL OPEN csr109;
	while(1) {
	    EXEC SQL FETCH csr109 INTO :id;
	    if (sqlca.sqlcode != 0) break; 
	    
	    sq_save_data(sq, hash_lookup(lists, id));
	}
	EXEC SQL CLOSE csr109;
	generic_fix(sq, show_list_name, "Change name", cant_fix, 0);
    }

    dprintf("Loading filesys...\n");
    sq = sq_create();
    filesys = create_hash(30000);
    if(!sq || !filesys) out_of_mem("loading filesys");

    EXEC SQL DECLARE csr110 CURSOR FOR
	SELECT filsys_id, label, owner, owners, phys_id, mach_id,
	        type, name, modby FROM filesys ORDER BY filsys_id;
    EXEC SQL OPEN csr110;
    while(1) {
	EXEC SQL FETCH csr110 INTO :id, :name, :aid, :aid2, :id2, :id3, 
	    :buf, :name1, :sid;
	if (sqlca.sqlcode != 0) break;

    	f = (struct filesys *) malloc(sizeof(struct filesys));
	if (f == NULL)
	  out_of_mem("storing filesystems");
	strcpy(f->name, strtrim(name));
	strcpy(f->dir, strtrim(name1));
	f->filsys_id = id;
	f->owner = aid;
	f->owners = aid2;
	f->phys_id = id2;
	f->mach_id = id3;
	f->type = buf[0];
	retval = hash_store(filesys, id, f);
	if ( retval == -1 ) {
	    out_of_mem("storing filesys in hash table");
	} else if ( retval == 1 ) {
	    sq_save_data(sq, hash_lookup(filesys, id));
	    sq_save_data(sq, f);
	}
    }
    EXEC SQL CLOSE csr110;

    generic_fix(sq, show_fs_id, "Change ID", fix_fs_id, 0);

    dprintf("Loading nfsphys...\n");
    sq = sq_create();
    nfsphys = create_hash(500);
    if(!sq || !nfsphys) out_of_mem("loading nfsphs");

    EXEC SQL DECLARE csr111 CURSOR FOR
	SELECT nfsphys_id, dir, mach_id, allocated, modby FROM nfsphys;
    EXEC SQL OPEN csr111;
    while(1) {
	EXEC SQL FETCH csr111 INTO :id, :name, :id2, :id3, :sid;
	if (sqlca.sqlcode != 0) break; 

    	n = (struct nfsphys *) malloc(sizeof(struct nfsphys));
	if (n == NULL)
	  out_of_mem("storing nfsphys");
	strcpy(n->dir, strtrim(name));
	n->mach_id = id2;
	n->nfsphys_id = id;
	n->allocated = id3;
	n->count = 0;
	retval = hash_store(nfsphys, id, n);
	if ( retval == -1 ) {
	    out_of_mem("storing nfsphys in hash table");
	} else if ( retval == 1 ) {
	    sq_save_data(sq, hash_lookup(nfsphys, id));
	    sq_save_data(sq, n);
	}
    }
    EXEC SQL CLOSE csr111;

    generic_fix(sq, show_np_id, "Change ID", fix_np_id, 0);

    /* csr112 */
    
}
