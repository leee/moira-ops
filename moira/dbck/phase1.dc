/* $Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/dbck/phase1.dc,v 1.4 1993-02-09 16:46:37 mar Exp $
 *
 *  (c) Copyright 1988 by the Massachusetts Institute of Technology.
 *  For copying and distribution information, please see the file
 *  <mit-copyright.h>.
 */

#include <mit-copyright.h>
#include <moira.h>
#include "dbck.h"
EXEC SQL INCLUDE sqlca;


static char phase1_qc_rcsid[] = "$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/dbck/phase1.dc,v 1.4 1993-02-09 16:46:37 mar Exp $";


show_user_id(u)
struct user *u;
{
    printf("User %s (%s, status %d) has duplicate ID\n",
	   u->login, u->fullname, u->status);
    return(0);
}

handle_duplicate_logins(sq)
struct save_queue *sq;
{
    struct user *u, *uu, *tmp;

    uu = (struct user *)0;
    if(sq_get_data(sq,&uu)) {
      while (sq_get_data(sq, &u)) {
	if (!strcmp(u->login, uu->login)) {
	    if (uu->status == 1 || u->status == 0) {
		tmp = u;
		u = uu;
		uu = tmp;
	    }
	    printf("User %s (%s, status %d) and\n",
		   u->login, u->fullname, u->status);
	    printf("User %s (%s, status %d) have duplicate logins\n",
		   uu->login, uu->fullname, uu->status);
	    if (!strcmp(u->fullname, uu->fullname) &&
		single_fix("Delete the second one")) {
		single_delete("users", "users_id", uu->users_id);
	    } else if (single_fix("Unregister the second one"))
	      {
		EXEC SQL BEGIN DECLARE SECTION; 
    		int id = uu->users_id, rowcount;
		EXEC SQL END DECLARE SECTION; 

		EXEC SQL UPDATE users SET login = '#'+CHAR(users.uid),
		    status=0 WHERE users_id = :id;
		EXEC SQL INQUIRE_SQL(:rowcount = rowcount);
    		if (rowcount > 0)
		  printf("%d entr%s fixed\n", rowcount, rowcount==1?"y":"ies");
		else
		  printf("Not fixed\n");
		modified("users");
	      }
	} else {
	    uu = u;
	}
      }
    }
}

fix_user_id(u)
struct user *u;
{
    u->users_id = generic_fix_id("users", "users_id", "login",
				 u->users_id, u->login);
}


cant_fix(id)
int id;
{
    printf("Sorry, don't know how to fix that\n");
}

show_mach_id(m)
struct machine *m;
{
    printf("Machine %s has duplicate ID %d\n", m->name, m->mach_id);
    return(0);
}

show_mach_name(m)
struct machine *m;
{
    printf("Machine %s (%d) has duplicate name\n", m->name, m->mach_id);
    return(0);
}

fix_mach_id(m)
struct machine *m;
{
    m->mach_id = generic_fix_id("machine", "mach_id", "name",
				m->mach_id, m->name);
}

show_clu_id(c)
struct cluster *c;
{
    printf("Cluster %s has duplicate ID %d\n", c->name, c->clu_id);
    return(0);
}

show_clu_name(c)
struct cluster *c;
{
    printf("Cluster %s (%d) has duplicate name\n", c->name, c->clu_id);
    return(0);
}

fix_clu_id(c)
struct cluster *c;
{
    c->clu_id = generic_fix_id("cluster", "clu_id", "name", c->clu_id, c->name);
}

show_list_id(l)
struct list *l;
{
    printf("List %s has duplicate ID %d\n", l->name, l->list_id);
    return(0);
}

show_list_name(l)
struct list *l;
{
    printf("List %s (%d) has duplicate name\n", l->name, l->list_id);
    return(0);
}

fix_list_id(l)
struct list *l;
{
    l->list_id = generic_fix_id("list", "list_id", "name", l->list_id, l->name);
}

show_fs_id(f)
struct filesys *f;
{
    printf("Filesys %s has duplicate ID %d\n", f->name, f->filsys_id);
    return(0);
}

fix_fs_id(f)
struct filesys *f;
{
    f->filsys_id = generic_fix_id("filesys", "filsys_id", "label",
				  f->filsys_id, f->name);
}


show_np_id(n)
struct nfsphys *n;
{
    printf("NfsPhys %s:%s has duplicate ID %d\n",
	   ((struct machine *)hash_lookup(machines, n->mach_id))->name,
	   n->dir, n->nfsphys_id);
    return(0);
}

fix_np_id(n)
struct nfsphys *n;
{
    n->nfsphys_id = generic_fix_id("nfsphys", "nfsphys_id", "dir",
				   n->nfsphys_id, n->dir);
}

show_str_id(s)
struct string *s;
{
    printf("String %s has duplicate ID %d\n", s->name, s->string_id);
    return(0);
}


phase1()
{
    EXEC SQL BEGIN DECLARE SECTION; 
    char name[81], name1[81], last[17], first[17], buf[257];
    int id, id2, id3, aid, aid2, status, sid, sid2, sid3, sid4, sid5;
    EXEC SQL END DECLARE SECTION; 
    struct save_queue *sq;
    struct user *u;
    struct machine *m;
    struct list *l;
    struct cluster *c;
    struct string *s;
    struct filesys *f;
    struct nfsphys *n;

    printf("Phase 1 - Looking for duplicates\n");

    dprintf("Loading strings...\n");
    sq = sq_create();
    strings = create_hash(5000);

    EXEC SQL DECLARE csr101 CURSOR FOR
      SELECT string_id, string FROM strings ORDER BY string_id;
    EXEC SQL OPEN csr101;
    while(1) {
	EXEC SQL FETCH csr101 INTO :id, :buf;
	if (sqlca.sqlcode != 0) {
	  ingerr(&sqlca.sqlcode);
	  break;
	}

    	s = (struct string *) malloc(sizeof(struct string));
	if (s == NULL)
	  out_of_mem("storing strings");
	s->name = strsave(strtrim(buf));
	s->string_id = id;
	s->refc = 0;
	if (hash_store(strings, id, s)) {
	    sq_save_data(sq, hash_lookup(strings, id));
	    sq_save_data(sq, s);
	}
    }
    EXEC SQL CLOSE csr101;
    generic_delete(sq, show_str_id, "strings", "string_id", 0);
    string_check(0);

    dprintf("Loading users...\n");
    sq = sq_create();
    users = create_hash(10000);

    EXEC SQL DECLARE csr102 CURSOR FOR 
      SELECT users_id, login, last, first, status, potype, pop_id, box_id,
	  modby, fmodby, pmodby, comment, sigwho FROM users ORDER BY users_id;
    EXEC SQL OPEN csr102;
    while(1) {
	EXEC SQL FETCH csr102 INTO :id, :name, :last, :first, :status,
            :buf, :id2, :id3, :sid, :sid2, :sid3, :sid4, :sid5;
	if (sqlca.sqlcode != 0) {
	  ingerr(&sqlca.sqlcode);
	  break;
	}

    	u = (struct user *) malloc(sizeof(struct user));
	if (u == NULL)
	  out_of_mem("storing users");
	strcpy(u->login, strtrim(name));
	u->potype = buf[0];
	sprintf(buf, "%s, %s", strtrim(last), strtrim(first));
	u->fullname = strsave(buf);
	u->status = status;
	u->users_id = id;
	switch (u->potype) {
	case 'P':
	    u->pobox_id = id2;
	    break;
	case 'S':
	    u->pobox_id = id3;
	    break;
	default:
	    u->pobox_id = 0;
	}
	if (hash_store(users, id, u)) {
	    sq_save_data(sq, hash_lookup(users, id));
	    sq_save_data(sq, u);
	}
	if (sid < 0)
	  string_check(-sid);
	if (sid2 < 0)
	  string_check(-sid2);
	if (sid3 < 0)
	  string_check(-sid3);
	if (sid4)
	  string_check(sid4);
	if (sid5)
	  string_check(sid5);
    }
    EXEC SQL CLOSE csr102; 

    generic_fix(sq, show_user_id, "Change ID", fix_user_id, 0);

    if (!fast) {
	sq = sq_create();

	EXEC SQL DECLARE csr103 CURSOR FOR 
	    SELECT u1.users_id FROM users u1, users u2
	    WHERE u1.login = u2.login and u1.tid != u2.tid;
	EXEC SQL OPEN csr103;
	while(1) {
	    EXEC SQL FETCH csr103 INTO :id;
	    if (sqlca.sqlcode != 0) {
		ingerr(&sqlca.sqlcode);
		break;
	    }
	    sq_save_data(sq, hash_lookup(users, id));
	}
	EXEC SQL CLOSE csr103; 
	handle_duplicate_logins(sq);
    }

    dprintf("Loading machines...\n");
    machines = create_hash(1000);
    sq = sq_create();

    EXEC SQL DECLARE csr104 CURSOR FOR
	SELECT mach_id, name, modby FROM machine ORDER BY mach_id;
    EXEC SQL OPEN csr104;
    while(1) {
	EXEC SQL FETCH csr104 INTO :id, :name, :sid;
	if (sqlca.sqlcode != 0) {
	  ingerr(&sqlca.sqlcode);
	  break;
	} 

    	m = (struct machine *) malloc(sizeof(struct machine));
	if (m == NULL)
	  out_of_mem("storing machines");
	strcpy(m->name, strtrim(name));
	m->mach_id = id;
	m->clucount = 0;
	if (hash_store(machines, id, m)) {
	    sq_save_data(sq, hash_lookup(machines, id));
	    sq_save_data(sq, m);
	}
	if (sid < 0)
	  string_check(-sid);
    }
    EXEC SQL CLOSE csr104; 
    generic_fix(sq, show_mach_id, "Change ID", fix_mach_id, 0);

    if (!fast) {
	sq = sq_create();

	EXEC SQL DECLARE csr105 CURSOR FOR
	    SELECT m1.mach_id FROM machine m1, machine m2
		WHERE m1.name = m2.name AND m1.tid != m2.tid;
	EXEC SQL OPEN csr105;
	while(1) {
	    EXEC SQL FETCH csr105 INTO :id;
	    if (sqlca.sqlcode != 0) {
		ingerr(&sqlca.sqlcode);
		break;
	    } 

	    sq_save_data(sq, hash_lookup(machines, id));
	}
	EXEC SQL CLOSE csr105; 
	generic_fix(sq, show_mach_name, "Change name", cant_fix, 0);
    }	

    dprintf("Loading clusters...\n");
    sq = sq_create();
    clusters = create_hash(100);

    EXEC SQL DECLARE csr106 CURSOR FOR
	SELECT clu_id, name, modby FROM cluster;
    EXEC SQL OPEN csr106;
    while(1) {
	EXEC SQL FETCH csr106 INTO :id, :name, :sid;
	if (sqlca.sqlcode != 0) {
	  ingerr(&sqlca.sqlcode);
	  break;
	} 

    	c = (struct cluster *) malloc(sizeof(struct cluster));
	if (c == NULL)
	  out_of_mem("storing clusters");
	strcpy(c->name, strtrim(name));
	c->clu_id = id;
	if (hash_store(clusters, id, c)) {
	    sq_save_data(sq, hash_lookup(clusters, id));
	    sq_save_data(sq, c);
	}
	if (sid < 0)
	  string_check(-sid);
    }
    EXEC SQL CLOSE csr106; 
    generic_fix(sq, show_clu_id, "Change ID", fix_clu_id, 0);

    if (!fast) {
	sq = sq_create();

	EXEC SQL DECLARE csr107 CURSOR FOR
	    SELECT c1.clu_id FROM cluster c1, cluster c2
		WHERE c1.name=c2.name AND c1.tid != c2.tid;
	EXEC SQL OPEN csr107;
	while(1) {
	    EXEC SQL FETCH csr107 INTO :id;
	    if (sqlca.sqlcode != 0) {
		ingerr(&sqlca.sqlcode);
		break;
	    } 

	    sq_save_data(sq, hash_lookup(clusters, id));
	}
	EXEC SQL CLOSE csr107; 
	generic_fix(sq, show_clu_name, "Change name", cant_fix, 0);
    }

    dprintf("Loading lists...\n");
    sq = sq_create();
    lists = create_hash(10000);

    EXEC SQL DECLARE csr108 CURSOR FOR
	SELECT list_id, name, acl_id, acl_type, modby  FROM list 
	ORDER BY list_id;
    EXEC SQL OPEN csr108;
    while(1) {
	EXEC SQL FETCH csr108 INTO :id, :name, :aid, :buf, :sid;
	if (sqlca.sqlcode != 0) {
	  ingerr(&sqlca.sqlcode);
	  break;
	}
    	l = (struct list *) malloc(sizeof(struct list));
	if (l == NULL)
	  out_of_mem("storing lists");
	strcpy(l->name, strtrim(name));
	l->acl_type = buf[0];
	l->acl_id = aid;
	l->list_id = id;
	l->members = 0;
	if (hash_store(lists, id, l)) {
	    sq_save_data(sq, hash_lookup(lists, id));
	    sq_save_data(sq, l);
	}
	if (sid < 0)
	  string_check(-sid);
    }
    EXEC SQL CLOSE csr108; 
    generic_fix(sq, show_list_id, "Change ID", fix_list_id, 0);

    if (!fast) {
	sq = sq_create();

	EXEC SQL DECLARE csr109 CURSOR FOR
	    SELECT l1.list_id FROM list l1, list l2
		WHERE l1.name=l2.name AND l1.tid != l2.tid;
	EXEC SQL OPEN csr109;
	while(1) {
	    EXEC SQL FETCH csr109 INTO :id;
	    if (sqlca.sqlcode != 0) {
		ingerr(&sqlca.sqlcode);
		break;
	    } 
	    
	    sq_save_data(sq, hash_lookup(lists, id));
	}
	EXEC SQL CLOSE csr109;
	generic_fix(sq, show_list_name, "Change name", cant_fix, 0);
    }

    dprintf("Loading filesys...\n");
    sq = sq_create();
    filesys = create_hash(10000);

    EXEC SQL DECLARE csr110 CURSOR FOR
	SELECT filsys_id, label, owner, owners, phys_id, mach_id,
	        type, name, modby FROM filesys ORDER BY filsys_id;
    EXEC SQL OPEN csr110;
    while(1) {
	EXEC SQL FETCH csr110 INTO :id, :name, :aid, :aid2, :id2, :id3, 
	    :buf, :name1, :sid;
	if (sqlca.sqlcode != 0) {
	  ingerr(&sqlca.sqlcode);
	  break;
	}

    	f = (struct filesys *) malloc(sizeof(struct filesys));
	if (f == NULL)
	  out_of_mem("storing filesystems");
	strcpy(f->name, strtrim(name));
	strcpy(f->dir, strtrim(name1));
	f->filsys_id = id;
	f->owner = aid;
	f->owners = aid2;
	f->phys_id = id2;
	f->mach_id = id3;
	f->type = buf[0];
	if (hash_store(filesys, id, f)) {
	    sq_save_data(sq, hash_lookup(filesys, id));
	    sq_save_data(sq, f);
	}
	if (sid < 0)
	  string_check(-sid);
    }
    EXEC SQL CLOSE csr110;

    generic_fix(sq, show_fs_id, "Change ID", fix_fs_id, 0);

    dprintf("Loading nfsphys...\n");
    sq = sq_create();
    nfsphys = create_hash(500);

    EXEC SQL DECLARE csr111 CURSOR FOR
	SELECT nfsphys_id, dir, mach_id, allocated, modby FROM nfsphys;
    EXEC SQL OPEN csr111;
    while(1) {
	EXEC SQL FETCH csr111 INTO :id, :name, :id2, :id3, :sid;
	if (sqlca.sqlcode != 0) {
	    ingerr(&sqlca.sqlcode);
	    break;
	} 

    	n = (struct nfsphys *) malloc(sizeof(struct nfsphys));
	if (n == NULL)
	  out_of_mem("storing nfsphys");
	strcpy(n->dir, strtrim(name));
	n->mach_id = id2;
	n->nfsphys_id = id;
	n->allocated = id3;
	n->count = 0;
	if (hash_store(nfsphys, id, n)) {
	    sq_save_data(sq, hash_lookup(nfsphys, id));
	    sq_save_data(sq, n);
	}
	if (sid < 0)
	  string_check(-sid);
    }
    EXEC SQL CLOSE csr111;

    generic_fix(sq, show_np_id, "Change ID", fix_np_id, 0);

    if (!fast) {

	EXEC SQL DECLARE csr112 CURSOR FOR
	    SELECT s1.string_id, s1.string FROM strings s1, strings s2
		WHERE s1.string=s2.string AND s1.tid != s2.tid;
	EXEC SQL OPEN csr112;
	while(1) {
	    EXEC SQL FETCH csr112 INTO :id, :buf;
	    if (sqlca.sqlcode != 0) {
		ingerr(&sqlca.sqlcode);
		break;
	    } 

	    printf("String %s(%d) is a duplicate!\n", strtrim(buf), id);
	    printf("Not fixing this error\n");
	}
	EXEC SQL CLOSE csr112;
    }

    if (!fast) {
	dprintf("Scanning krbmap...\n");

	EXEC SQL DECLARE csr113 CURSOR FOR
	    SELECT k1.users_id FROM krbmap k1, krbmap k2
		WHERE k1.users_id = k2.users_id AND k1.tid != k2.tid;
	EXEC SQL OPEN csr113;
	while(1) {
	    EXEC SQL FETCH csr113 INTO :id;
	    if (sqlca.sqlcode != 0) {
		ingerr(&sqlca.sqlcode);
		break;
	    } 

	    printf("User %d is in the krbmap more than once!\n", id);
	    printf("Not fixing this error\n");
	}
	EXEC SQL CLOSE csr113; 

	EXEC SQL DECLARE csr114 CURSOR FOR
	    SELECT k1.string_id FROM krbmap k1, krbmap k2
		WHERE k1.string_id = k2.string_id AND k1.tid != k2.tid;
	EXEC SQL OPEN csr114;
	while(1) {
	    EXEC SQL FETCH csr114 INTO :id;
	    if (sqlca.sqlcode != 0) {
		ingerr(&sqlca.sqlcode);
		break;
	    } 

	    printf("Principal %d is in the krbmap more than once!\n", id);
	    printf("Not fixing this error\n");
	}
	EXEC SQL CLOSE csr114; 
    }
}
