/* $Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/dbck/phase2.pc,v 1.1 1997-01-29 23:13:15 danw Exp $
 *
 *  (c) Copyright 1988 by the Massachusetts Institute of Technology.
 *  For copying and distribution information, please see the file
 *  <mit-copyright.h>.
 */

#include <mit-copyright.h>
#include <stdio.h>
#include <moira.h>
#include "dbck.h"
EXEC SQL INCLUDE sqlca;

static char phase2_qc_rcsid[] = "$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/dbck/phase2.pc,v 1.1 1997-01-29 23:13:15 danw Exp $";

EXEC SQL WHENEVER SQLERROR DO dbmserr();

show_mcm_mach(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int iid = id, found = 1;
    char name[33];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr201 CURSOR FOR
      SELECT clusters.name FROM clusters, mcmap
        WHERE clusters.clu_id=mcmap.clu_id AND mcmap.mach_id = :iid;
    EXEC SQL OPEN csr201;
    while(1) {
	EXEC SQL FETCH csr201 INTO :name;
	if (sqlca.sqlcode != 0) break; 

	strtrim(name);
	found = 0;
	printf("Cluster %s, non-existant machine %d in cluster map\n", name, id);
    }
    EXEC SQL CLOSE csr201; 
    return(found);
}

show_mcm_clu(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int iid = id, found = 1;
    char name[33];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr202 CURSOR FOR
        SELECT machine.name FROM machine, mcmap
        WHERE machine.mach_id=mcmap.mach_id AND mcmap.clu_id=:iid;
    EXEC SQL OPEN csr202;
    while(1) {
	EXEC SQL FETCH csr202 INTO :name;
	if (sqlca.sqlcode != 0) break; 

	strtrim(name);

	found = 0;
	printf("Machine %s, non-existant cluster %d in cluster map\n", name, id);
    }
    EXEC SQL CLOSE csr202; 
    return(found);
}

show_hostalias(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int iid = id, found = 1;
    char name[33];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr234 CURSOR FOR
      SELECT name FROM hostalias WHERE mach_id=:iid;
    EXEC SQL OPEN csr234;
    while(1) {
	EXEC SQL FETCH csr234 INTO :name;
	if (sqlca.sqlcode != 0) break; 

	strtrim(name);

	found = 0;
	printf("Alias %s, non-existant machine %d in hostalias map\n", name, id);
    }
    EXEC SQL CLOSE csr234;
    return(found);
}

show_pcap_mach(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int iid = id, found = 1;
    char name[33];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr235 CURSOR FOR
      SELECT name FROM printcap WHERE mach_id=:iid;
    EXEC SQL OPEN csr235;
    while(1) {
	EXEC SQL FETCH csr235 INTO :name;
	if (sqlca.sqlcode != 0) break; 

	strtrim(name);

	found = 0;
	printf("Printer %s, non-existant spool machine %d in printcap table\n", name, id);
    }
    EXEC SQL CLOSE csr235;
    return(found);
}

show_pcap_quota(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int iid = id, found = 1;
    char name[33];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr236 CURSOR FOR
      SELECT name FROM printcap WHERE quotaserver=:iid;
    EXEC SQL OPEN csr236;
    while(1) {
	EXEC SQL FETCH csr236 INTO :name;
	if (sqlca.sqlcode != 0) break; 

	strtrim(name);

	found = 0;
	printf("Printer %s, non-existant quota server %d in printcap table\n", name, id);
    }
    EXEC SQL CLOSE csr236;
    return(found);
}

user_check(id, u, hint)
     int id;
     struct user *u;
     int hint;
{
  u->comment=maybe_fixup_unref_string(u->comment, id, u->login, "users",
				      "comments", "users_id");

  u->modby=maybe_fixup_modby(u->modby, id, u->login, "users",
			     "modby", "users_id");

  u->fmodby=maybe_fixup_modby(u->fmodby, id, u->login, "users",
			      "fmodby", "users_id");

  u->pmodby=maybe_fixup_modby(u->pmodby, id, u->login, "users",
			      "pmodby", "users_id");

  u->sigwho=maybe_fixup_unref_string(u->sigwho, id, u->login, "users",
				     "sigwho", "users_id");
  
  pobox_check(id, u, hint);
}

maybe_fixup_unref_string(sid, oid, oname, table, field, idfield)
     int sid, oid;
     char *oname, *table;
     char *field, *idfield;
{
  int ret=(sid<0)?-sid:sid, doit=0, newid;
  EXEC SQL BEGIN DECLARE SECTION;
  int rowcount;
  char stmt_buf[500];
  EXEC SQL END DECLARE SECTION;
  
  if(newid=int_hash_lookup(string_dups, ret)) {
    printf("%s entry %s(%d) has a %s with duplicate string %d\n",
	   table, oname, oid, field, ret);
    if(single_fix("Replace duplicate", 0)){
      ret = newid;
      string_check(newid);
      doit=1;
    }
  } else if(!string_check(ret)) {
    printf("%s entry %s(%d) has a %s with non-existant string %d\n",
	   table, oname, oid, field, ret);
    if (single_fix("Delete", 1)) {
      ret=0;
      doit=1;
    }
  }

  if(doit){
    sprintf(stmt_buf, "UPDATE %s SET %s = %d WHERE %s = %d",
	    table, field, (sid<0)?-ret:ret, idfield, oid);
    EXEC SQL EXECUTE IMMEDIATE :stmt_buf;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount == 1)
      printf("Fixed\n");
    else
      printf("Not fixed, rowcount = %d\n", rowcount);
    modified(table);
  }

  return((sid<0)?-ret:ret);

}

maybe_fixup_modby(sid, oid, oname, table, field, idfield)
     int sid, oid;
     char *oname, *table;
     char *field, *idfield;
{
  EXEC SQL BEGIN DECLARE SECTION;
  char stmt_buf[500];
  int rowcount;
  EXEC SQL END DECLARE SECTION;

  if(sid<0)
    return maybe_fixup_unref_string(sid, oid, oname, table, field, idfield);
  else {
    if(!hash_lookup(users, sid)) {
      printf("%s entry %s(%d) has a %s with non-existant user %d\n",
	     table, oname, oid, field, sid);
      if (single_fix("Delete", 1)) {
	sprintf(stmt_buf, "UPDATE %s SET %s = %d WHERE %s=%d",
		table, field, 0, idfield, oid);
	EXEC SQL EXECUTE IMMEDIATE :stmt_buf;
	rowcount = sqlca.sqlerrd[2];
	if (rowcount == 1)
	  printf("Fixed\n");
	else
	  printf("Not fixed, rowcount = %d\n", rowcount);
	modified(table);
      }
      return 0;
    }
  }
  return sid;
}

maybe_fixup_unref_string2(table, field, cursor, sid)
     int sid;
     char *field, *table, *cursor;
{
  int ret=(sid<0)?-sid:sid, doit=0, newid;
  EXEC SQL BEGIN DECLARE SECTION;
  int rowcount;
  char stmt_buf[500];
  EXEC SQL END DECLARE SECTION;
  
  if(newid=int_hash_lookup(string_dups, ret)) {
    printf("%s entry has a %s with duplicate string %d\n",
	   table, field, ret);
    if(single_fix("Replace duplicate", 0)){
      ret = newid;
      string_check(newid);
      doit=1;
    }
  } else if(!string_check(ret)) {
    printf("%s entry has a %s with non-existant string %d\n",
	   table, field, ret);
    if (single_fix("Delete", 1)) {
      ret=0;
      doit=1;
    }
  }

  if(doit){
    sprintf(stmt_buf, "UPDATE %s SET %s = %d WHERE CURRENT OF %s",
	    table, field, (sid<0)?-ret:ret, cursor);
    EXEC SQL EXECUTE IMMEDIATE :stmt_buf;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount == 1)
      printf("Fixed\n");
    else
      printf("Not fixed, rowcount = %d\n", rowcount);
    modified(table);
  }
  return((sid<0)?-ret:ret);
}

maybe_fixup_modby2(table, field, cursor, id)
{
  EXEC SQL BEGIN DECLARE SECTION;
  char stmt_buf[500];
  int rowcount;
  EXEC SQL END DECLARE SECTION;

  if(id<0) return maybe_fixup_unref_string2(table, field, cursor, id);
  else {
    if(!hash_lookup(users, id)) {
      printf("%s entry has a %s with non-existant user %d\n",
	     table, field, id);
      if (single_fix("Delete", 1)) {
	sprintf(stmt_buf, "UPDATE %s SET %s = %d WHERE CURRENT OF %s",
		table, field, 0, cursor);
	EXEC SQL EXECUTE IMMEDIATE :stmt_buf;
	rowcount = sqlca.sqlerrd[2];
	if (rowcount == 1)
	  printf("Fixed\n");
	else
	  printf("Not fixed, rowcount = %d\n", rowcount);
	modified(table);
      }
      return 0;
    }
  }
  return 1;
}

pobox_check(id, u, hint)
int id;
struct user *u;
int hint;
{
  switch (u->potype) {
  case 'P':
    if (!hash_lookup(machines, u->pobox_id)) {
      printf("User %s(%s) has P.O.Box on non-existant machine %d\n",
	     u->login, u->fullname, u->pobox_id);
      if (single_fix("Delete", 0)) {
	remove_pobox(u->users_id);
	u->potype = 'N';
      }
    }
    break;
  case 'S':
    if( int_hash_lookup( string_dups, u->pobox_id ) ) {
      printf("User %s(%s) has P.O.Box with duplicate string %d\n",
	     u->login, u->fullname, u->pobox_id);
      if(single_fix("Update", 0)){
	printf("Replacing box_id dup string ID %d with %d\n",
	       u->pobox_id,
	       int_hash_lookup(string_dups, u->pobox_id));
	u->pobox_id = int_hash_lookup( string_dups, u->pobox_id );
	fix_smtp_pobox(u->users_id, u->pobox_id);
	string_check(u->pobox_id);
      }
    } else if (!string_check(u->pobox_id)) {
      printf("User %s(%s) has P.O.Box with non-existant string %d\n",
	     u->login, u->fullname, u->pobox_id);
      if (single_fix("Delete", 0)) {
	remove_pobox(u->users_id);
	u->potype = 'N';
      }
    }
    break;
  default:
    ;
  }
}


remove_pobox(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount, iid = id;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL UPDATE users SET potype='NONE' WHERE users.users_id = :iid;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s removed\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not removed\n");
    modified("users");
}

fix_smtp_pobox(id, sid)
int id, sid;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount, iid = id, isid=sid;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL UPDATE users SET box_id=:isid WHERE users.users_id = :iid;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s updated\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not updated\n");
    modified("users");
}

mach_check(id, m, hint)
int id;
struct machine *m;
int hint;
{
    if (!hash_lookup(subnets, m->snet_id)) {
	printf("Machine %s is on a non-existant subnet %d\n",
	       m->name, m->snet_id);
	if (single_fix("Move to null-subnet", 1)) {
	    EXEC SQL BEGIN DECLARE SECTION; 
	    int rowcount, iid = id;
	    EXEC SQL END DECLARE SECTION; 

	    EXEC SQL UPDATE machine SET snet_id=0 WHERE mach_id = :iid;
	    rowcount = sqlca.sqlerrd[2];
	    if (rowcount > 0)
	      printf("%d entr%s fixed\n", rowcount, rowcount==1?"y":"ies");
	    else
	      printf("Not fixed\n");
	    modified("machine");
	}
    }

    switch (m->owner_type) {
    case 'U':
	if (!hash_lookup(users, m->owner_id)) {
	    printf("Machine %s has non-existant USER owner %d\n",
		   m->name, m->owner_id);
	    if (single_fix("Set to no owner", 1)) {
		clear_mach_owner(m);
	    }
	}
	break;
    case 'L':
	if (!hash_lookup(lists, m->owner_id)) {
	    printf("Machine %s has non-existant LIST owner %d\n",
		   m->name, m->owner_id);
	    if (single_fix("Set to no owner", 1)) {
		clear_mach_owner(m);
	    }
	}
	break;
    case 'S':
    case 'K':
      if(m->owner_id)
	m->owner_id=maybe_fixup_unref_string(m->owner_id, id, m->name,
					     "machine", "owner_id", "mach_id");
      if(m->owner_id==0)
	clear_mach_owner(m);
    }

    if(m->acomment)
      m->acomment=maybe_fixup_unref_string(m->acomment, id, m->name,
					   "machine", "acomment", "mach_id");
    if(m->ocomment)
      m->ocomment=maybe_fixup_unref_string(m->ocomment, id, m->name,
					   "machine", "ocomment", "mach_id");
    
    m->creator=maybe_fixup_modby(m->creator, id, m->name, "machine",
				 "creator", "mach_id");
    m->modby=maybe_fixup_modby(m->modby, id, m->name, "machine",
			       "modby", "mach_id");
}

subnet_check(id, s, hint)
int id;
struct subnet *s;
int hint;
{
    switch (s->owner_type) {
    case 'U':
	if (!hash_lookup(users, s->owner_id)) {
	    printf("Subnet %s has non-existant USER owner %d\n",
		   s->name, s->owner_id);
	    if (single_fix("Set to no owner", 1)) {
		clear_subnet_owner(s);
	    }
	}
	break;
    case 'L':
	if (!hash_lookup(lists, s->owner_id)) {
	    printf("Machine %s has non-existant LIST owner %d\n",
		   s->name, s->owner_id);
	    if (single_fix("Set to no owner", 1)) {
		clear_subnet_owner(s);
	    }
	}
	break;
    case 'S':
    case 'K':
      if(s->owner_id)
	s->owner_id=maybe_fixup_unref_string(s->owner_id, id, s->name,
					     "machine", "owner_id", "mach_id");
      if(s->owner_id==0)
	clear_subnet_owner(s);
    }

    s->modby=maybe_fixup_modby(s->modby, id, s->name, "subnet",
			       "modby", "snet_id");
}


clear_subnet_owner(s)
struct subnet *s;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount, id = s->snet_id;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL UPDATE subnet SET owner_type='NONE', owner_id=0
      WHERE snet_id = :id;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s fixed\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not fixed\n");
    modified("subnet");
}

clear_mach_owner(m)
struct machine *m;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount, id = m->mach_id;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL UPDATE machine SET owner_type='NONE', owner_id=0
      WHERE mach_id = :id;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s fixed\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not fixed\n");
    modified("machine");
}

cluster_check(id, c, hint)
int id;
struct cluster *c;
int hint;
{
    c->modby=maybe_fixup_modby(c->modby, id, c->name, "clusters",
			       "modby", "clu_id");
}



show_svc(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int iid = id, found = 1;
    char label[17], data[33];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr203 CURSOR FOR
	SELECT serv_label, serv_cluster FROM svc
	    WHERE clu_id = :iid;
    EXEC SQL OPEN csr203;
    while(1) {
	EXEC SQL FETCH csr203 INTO :label, :data;
	if (sqlca.sqlcode != 0) break;

	strtrim(label);
	strtrim(data);
	found = 0;
	printf("Cluster data [%s] %s for non-existant cluster %d\n",
	       label, data, id);
    }
    EXEC SQL CLOSE csr203; 
    return(found);
}

list_check(id, l, hint)
int id;
struct list *l;
int hint;
{
    switch (l->acl_type) {
    case 'L':
	if (!hash_lookup(lists, l->acl_id)) {
	    printf("List %s has bad LIST acl %d\n", l->name, l->acl_id);
	    if (single_fix("Patch", 1)) {
		fix_list_acl(l->list_id);
	    }
	}
	break;
    case 'U':
	if (!hash_lookup(users, l->acl_id)) {
	    printf("List %s has bad USER acl %d\n", l->name, l->acl_id);
	    if (single_fix("Patch", 1)) {
		fix_list_acl(l->list_id);
	    }
	}
	break;
    case 'K':
        l->acl_id = maybe_fixup_unref_string(l->acl_id, id, l->name,
					     "list", "acl_id", "list_id");
        if (!l->acl_id) {
	    printf("List %s has bad KERBEROS acl %d\n", l->name, l->acl_id);
	    if(single_fix("Patch", 1)) {
	        fix_list_acl(l->list_id);
	    }
	}
	break;
    }
}

fix_list_acl(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount, iid = id;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL UPDATE list SET acl_id = :iid, acl_type='LIST'
	WHERE list_id = :iid;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s fixed\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not fixed\n");
    modified("list");
}


show_member_list(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int mid, iid = id, found = 1;
    char mtype[9], *name = "";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL DECLARE csr204 CURSOR FOR
	SELECT member_type, member_id FROM imembers
	    WHERE list_id = :iid AND direct=1;
    EXEC SQL OPEN csr204;
    while(1) {
	EXEC SQL FETCH csr204 INTO :mtype, :mid;
	if (sqlca.sqlcode != 0) break; 

	strtrim(mtype);
	found = 0;
	if (mtype[0] == 'L')
	    name = ((struct list *) hash_lookup(lists, mid))->name;
	else if (mtype[0] == 'U')
	    name = ((struct user *) hash_lookup(users, mid))->login;
	else if (mtype[0] == 'S' || mtype[0] == 'K')
	    name = ((struct string *) hash_lookup(strings, mid))->name;
	printf("Non-existant list %d has member %s %s\n", iid, mtype, name);
    }
    EXEC SQL CLOSE csr204; 
    return(found);
}

show_mem_user(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int lid, iid = id, found = 1;
    char name[33];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr205 CURSOR FOR
      SELECT list_id FROM imembers
	WHERE member_id = :iid AND member_type='USER' AND direct=1;
    EXEC SQL OPEN csr205;
    while(1) {
	EXEC SQL FETCH csr205 INTO :lid;
	if (sqlca.sqlcode != 0) break; 	
	
	found = 0;
	printf("List %s has non-existant user member, id %d\n",
	       ((struct list *)hash_lookup(lists, lid))->name, iid);
    }
    EXEC SQL CLOSE csr205;
    return(found);
}

show_mem_list(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int lid, iid = id, found = 1;
    char name[33];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr206 CURSOR FOR
	SELECT list_id FROM imembers
	    WHERE member_id = :iid AND member_type='LIST' AND direct=1;
    EXEC SQL OPEN csr206;
    while(1) {
	EXEC SQL FETCH csr206 INTO :lid;
	if (sqlca.sqlcode != 0) break; 

	found = 0;
	printf("List %s has non-existant list member, id %d\n",
	       ((struct list *)hash_lookup(lists, lid))->name, iid);
    }
    EXEC SQL CLOSE csr206; 
    return(found);
}

show_mem_str(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int lid, iid = id, found = 1;
    char name[33];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr207 CURSOR FOR
	SELECT list_id FROM imembers
	    WHERE member_id = :iid AND member_type='STRING' AND direct=1;
    EXEC SQL OPEN csr207;
    while(1) {
	EXEC SQL FETCH csr207 INTO :lid;
	if (sqlca.sqlcode != 0) break; 
	
	found = 0;
	printf("List %s has non-existant string member, id %d\n",
	       ((struct list *)hash_lookup(lists, lid))->name, iid);
    }
    EXEC SQL CLOSE csr207; 
    return(found);
}


show_mem_krb(id)
int id;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int lid, iid = id, found = 1;
    char name[33];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr208 CURSOR FOR
	SELECT list_id FROM imembers
	    WHERE member_id = :iid AND member_type='KERBEROS' AND direct=1;
    EXEC SQL OPEN csr208;
    while(1) {
	EXEC SQL FETCH csr208 INTO :lid;
	if (sqlca.sqlcode != 0) break; 

	found = 0;
	printf("List %s has non-existant kerberos member, id %d\n",
	       ((struct list *)hash_lookup(lists, lid))->name, iid);
    }
    EXEC SQL CLOSE csr208; 
    return(found);
}


del_mem_user(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DELETE FROM imembers WHERE member_type='USER' AND
	member_id = :id AND direct = 1;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s deleted\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not deleted\n");
    modified("imembers");
}

del_mem_list(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DELETE FROM imembers WHERE member_type='LIST' AND
	member_id = :id AND direct=1;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s deleted\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not deleted\n");
    modified("imembers");
}

del_mem_str(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DELETE FROM imembers WHERE member_type='STRING' AND
	member_id = :id AND direct=1;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s deleted\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not deleted\n");
    modified("imembers");
}


del_mem_krb(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DELETE FROM imembers WHERE member_type='KERBEROS' AND
	member_id = :id AND direct=1;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s deleted\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not deleted\n");
    modified("imembers");
}


show_sh(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    char name[33];
    EXEC SQL END DECLARE SECTION; 
    int found = 1;

    EXEC SQL DECLARE csr209 CURSOR FOR
	SELECT service FROM serverhosts
	    WHERE mach_id = :id;
    EXEC SQL OPEN csr209;
    while(1) {
	EXEC SQL FETCH csr209 INTO :name;
	if (sqlca.sqlcode != 0) break; 

	found = 0;
	printf("ServerHost entry for service %s non-existant host %d\n",
	       name, id);
    }
    EXEC SQL CLOSE csr209; 
    return(found);
}

del_sh_mach(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DELETE FROM serverhosts WHERE mach_id = :id;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s deleted\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not deleted\n");
    modified("serverhosts");
}


static int fnchecklen;

fsmatch(id, n, f)
int id;
struct nfsphys *n;
struct filesys *f;
{
    if (n->mach_id == f->mach_id &&
	!strncmp(f->dir, n->dir, strlen(n->dir)) &&
	strlen(n->dir) > fnchecklen) {
	f->phys_id = id;
	fnchecklen = strlen(n->dir);
    }
}


check_fs(id, f, hint)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
register struct filesys *f;
int hint;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int id1, id2, id3, rowcount;
    char *dir;
    EXEC SQL END DECLARE SECTION; 
    struct nfsphys *n;
    struct machine *m;

    if (!hash_lookup(machines, f->mach_id)) {
	printf("Filesys %s with bad machine %d\n", f->name, f->mach_id);
	if (single_fix("Fix", 0)) {
	    EXEC SQL UPDATE filesys SET mach_id = 0 WHERE filsys_id = :id;
	    rowcount = sqlca.sqlerrd[2];
	    if (rowcount > 0)
	      printf("%d entr%s fixed\n",rowcount, rowcount==1?"y":"ies");
	    else
	      printf("Not fixed\n");
	    modified("filesys");
	    f->mach_id = 0;
	}
    }

    if (!hash_lookup(users, f->owner)) {
	printf("Filesys %s with bad owning user %d\n", f->name, f->owner);
	if (single_fix("Fix", 1)) {
	    zero_fix("filesys", "owner", "filsys_id", f->filsys_id);
	    f->owner = 0;
	}
    }
    if (!hash_lookup(lists, f->owners)) {
	printf("Filesys %s with bad owning group %d\n", f->name, f->owners);
	if (single_fix("Fix", 1)) {
	    zero_fix("filesys", "owners", "filsys_id", f->filsys_id);
	    f->owners = 0;
	}
    }

    if (f->type == 'N') {
	if (!hash_lookup(nfsphys, f->phys_id)) {
	    m = (struct machine *)hash_lookup(machines, f->mach_id);
	    printf("Filesys %s with bad phys_id %d\n", f->name, f->phys_id);
	    if (single_fix("Fix", 1)) {
		fnchecklen = 0;
		hash_step(nfsphys, fsmatch, f);
		if (fnchecklen != 0) {
    		  id1 = f->phys_id;
		  id2 = f->filsys_id;
		  id3 = f->mach_id;
		  EXEC SQL UPDATE filesys SET phys_id = :id1 WHERE filsys_id = :id2;
		  rowcount = sqlca.sqlerrd[2];
		  if (rowcount > 0)
		    printf("%d entr%s fixed\n",rowcount, rowcount==1?"y":"ies");
		  else
		    printf("Not fixed\n");
		  modified("filesys");
		} else {
		    printf("No NFSphys exsits for %s:%s\n", m->name, f->dir);
		    if (single_fix("Create", 0)) {
			dir = f->dir;
			id1 = f->phys_id;
			id2 = f->filsys_id;
			id3 = f->mach_id;
			if (set_next_object_id("nfsphys_id", "nfsphys") !=
				MR_SUCCESS) {
			    printf("Unable to assign unique ID\n");
			    return;
			}
		        EXEC SQL SELECT COUNT(*) INTO :rowcount FROM numvalues 
			    WHERE name='nfsphys_id';
			if (rowcount != 1) {
			    printf("Unable to retrieve unique ID\n");
			    return;
			}
			EXEC SQL INSERT INTO mfsphys (mfsphys_id, mach_id,
			    device, dir, status, allocated, size, modtime,
			    modby, modwith) VALUES (:id1, :id3, '\?\?\?', :dir,
			    0, 0, 0, SYSDATE, 0, 'dbck');
			rowcount = sqlca.sqlerrd[2];
			if (rowcount > 0)
			  printf("%d entr%s created\n", rowcount,
				 rowcount==1?"y":"ies");
			else
			  printf("Not created\n");
			modified("nfsphys");
			n = (struct nfsphys *)malloc(sizeof(struct nfsphys));
			if (n == NULL)
			  out_of_mem("storing new nfsphys");
			strcpy(n->dir, dir);
			n->mach_id = id3;
			n->nfsphys_id = id1;
			n->allocated = 0;
			n->count = 0;
			if( hash_store(nfsphys, id1, n) == -1 ) {
			  out_of_mem("storing nfsphys in hash table");
			}
			EXEC SQL UPDATE filesys SET phys_id = :id1
			    WHERE filsys_id = :id2;
			rowcount = sqlca.sqlerrd[2];
			if (rowcount > 0)
			  printf("%d filesys entr%s fixed\n", rowcount,
				 rowcount==1?"y":"ies");
			else
			  printf("Not fixed\n");
			modified("filesys");
		    }
	        }
	    }
	}
    }
}


check_nfsphys(id, n, hint)
int id;
struct nfsphys *n;
int hint;
{
    if (!hash_lookup(machines, n->mach_id)) {
	printf("NFSphys %d(%s) on non-existant machine %d\n",
	       id, n->dir, n->mach_id);
	if (single_fix("Delete", 0))
	  single_delete("nfsphys", "nfsphys_id", id);
    }
}

show_fsg_missing(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int id1, found = 1;
    EXEC SQL END DECLARE SECTION; 
    struct filesys *f;

    EXEC SQL DECLARE csr210 CURSOR FOR
	SELECT filsys_id FROM fsgroup
	    WHERE group_id = :id;
    EXEC SQL OPEN csr210;
    while(1) {
	EXEC SQL FETCH csr210 INTO :id1;
	if (sqlca.sqlcode != 0) break; 

	found = 0;
	if (f = (struct filesys *) hash_lookup(filesys, id1))
	    printf("Missing fsgroup %d has member filesystem %s\n", id, f->name);
	else
	    printf("Missing fsgroup %d has member filesystem %d\n", id, id1);
    }
    EXEC SQL CLOSE csr210; 
    return(found);
}

show_fsg_type(f)
struct filesys *f;
{
    char *t;

    switch (f->type) {
    case 'N':
	t = "NFS";
	break;
    case 'R':
	t = "RVD";
	break;
    case 'A':
	t = "AFS";
	break;
    case 'E':
	t = "ERR";
	break;
    case 'F':
	t = "FSGROUP";
	break;
    case 'M':
	t = "MUL";
	break;
    default:
	t = "\?\?\?";
    }
    printf("FSGroup %s has type %s instead of FSGROUP\n", f->name, t);
    return(0);
}

fix_fsg_type(f)
struct filesys *f;
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount, id = f->filsys_id;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL UPDATE filesys SET type='FSGROUP' WHERE filsys_id = :id;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s fixed\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not fixed\n");
    modified("filesys");
}

show_fsg_nomember(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int id1, found = 1;
    EXEC SQL END DECLARE SECTION; 
    struct filesys *f;

    EXEC SQL DECLARE csr211 CURSOR FOR
	SELECT group_id FROM fsgroup
	    WHERE filsys_id = :id;
    EXEC SQL OPEN csr211;
    while(1) {
	EXEC SQL FETCH csr211 INTO :id1;
	if (sqlca.sqlcode != 0) break; 

	found = 0;
	if (f = (struct filesys *) hash_lookup(filesys, id1))
	    printf("FSGroup %s has missing member %d\n", f->name, id);
	else
	    printf("FSGroup %d has missing member %d\n", id1, id);
    }
    EXEC SQL CLOSE csr211; 
    return(found);
}

show_quota_nouser(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int id1, found = 1;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr212 CURSOR FOR
	SELECT filsys_id FROM quota
	    WHERE entity_id = :id AND type='USER';
    EXEC SQL OPEN csr212;
    while(1) {
	EXEC SQL FETCH csr212 INTO :id1;
	if (sqlca.sqlcode != 0) break; 

	found = 0;
	printf("Quota on fs %d for non-existant user %d\n", id1, id);
    }
    EXEC SQL CLOSE csr212; 
    return(found);
}

show_quota_nolist(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int id1, found = 1;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr213 CURSOR FOR
	SELECT filsys_id FROM quota 
	    WHERE entity_id = :id AND type='GROUP';
    EXEC SQL OPEN csr213;
    while(1) {
	EXEC SQL FETCH csr213 INTO :id1;
	if (sqlca.sqlcode != 0) break;
 
	found = 0;
	printf("Quota on fs %d for non-existant list %d\n", id1, id);
    }
    EXEC SQL CLOSE csr213; 
    return(found);
}

fix_quota_nouser(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount, id1;
    EXEC SQL END DECLARE SECTION; 

    id1 = ((struct filesys *)hash_lookup(filesys, id))->phys_id;
    EXEC SQL DELETE FROM quota 
	WHERE entity_id = :id AND type = 'USER';
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s deleted\n",rowcount, rowcount==1?"y":"ies");
    else
      printf("Not deleted\n");
    modified("quota");
}

fix_quota_nolist(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount, id1;
    EXEC SQL END DECLARE SECTION; 

    id1 = ((struct filesys *)hash_lookup(filesys, id))->phys_id;
    EXEC SQL DELETE FROM quota WHERE entity_id = :id AND type='GROUP';
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s deleted\n",rowcount, rowcount==1?"y":"ies");
    else
      printf("Not deleted\n");
    modified("quota");
}

show_quota_nofs(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int id1, found = 1;
    char type[9];
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL DECLARE csr214 CURSOR FOR
	SELECT entity_id, type FROM quota
	    WHERE filsys_id = :id;
    EXEC SQL OPEN csr214;
    while(1) {
	EXEC SQL FETCH csr214 INTO :id1, :type;
	if (sqlca.sqlcode != 0) break; 
	
	found = 0;
	printf("Quota for %s %d on non-existant filesys %d\n", type, id1, id);
    }
    EXEC SQL CLOSE csr214;
    return(found);
}

fix_quota_nofs(id)
{
    single_delete("quota", "filsys_id", id);
}

show_quota_wrongpid(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int id1, found = 1;
    char type[9];
    EXEC SQL END DECLARE SECTION; 
    struct user *u;
    struct filesys *f;

    f = (struct filesys *)hash_lookup(filesys, id);
    EXEC SQL DECLARE csr215 CURSOR FOR
	SELECT entity_id, type FROM quota
	    WHERE filsys_id = :id;
    EXEC SQL OPEN csr215;
    while(1) {
	EXEC SQL FETCH csr215 INTO :id1, :type;
	if (sqlca.sqlcode != 0) break; 

	found = 0;
	printf("Quota for %s %d on filesys %s has wrong phys_id %d\n",
	       type, id1, f->name, id);
    }
    EXEC SQL CLOSE csr215; 
    return(found);
}

fix_quota_physid(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount, id1;
    EXEC SQL END DECLARE SECTION; 

    id1 = ((struct filesys *)hash_lookup(filesys, id))->phys_id;
    EXEC SQL UPDATE quota SET phys_id = :id1 
	WHERE filsys_id = :id AND phys_id != :id1;
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s fixed\n",rowcount, rowcount==1?"y":"ies");
    else
      printf("Not fixed\n");
    modified("quota");
}

show_srv_user(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    char name[33];
    EXEC SQL END DECLARE SECTION; 
    int found = 1;

    EXEC SQL DECLARE csr216 CURSOR FOR
	SELECT name FROM servers
	    WHERE acl_type='USER' and acl_id = :id;
    EXEC SQL OPEN csr216;
    while(1) {
	EXEC SQL FETCH csr216 INTO :name;
	if (sqlca.sqlcode != 0) break; 
	
	strtrim(name);
	printf("Service %s has acl non-existant user %d\n", name, id);
	found = 0;
    }
    EXEC SQL CLOSE csr216; 
    return(found);
}

show_srv_list(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    char name[33];
    EXEC SQL END DECLARE SECTION; 
    int found = 1;

    EXEC SQL DECLARE csr217 CURSOR FOR
	SELECT name FROM servers
	    WHERE acl_type='LIST' AND acl_id = :id;
    EXEC SQL OPEN csr217;
    while(1) {
	EXEC SQL FETCH csr217 INTO :name;
	if (sqlca.sqlcode != 0) break; 

	strtrim(name);
	printf("Service %s has acl non-existant list %d\n", name, id);
	found = 0;
    }
    EXEC SQL CLOSE csr217; 
    return(found);
}

zero_srv_user(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL UPDATE servers SET acl_id=0 WHERE acl_id = :id AND
	acl_type='USER';
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s fixed\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not fixed\n");
    modified("servers");
}

zero_srv_list(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int rowcount;
    EXEC SQL END DECLARE SECTION; 

    EXEC SQL UPDATE servers SET acl_id=0 WHERE acl_id = :id AND
	acl_type='LIST';
    rowcount = sqlca.sqlerrd[2];
    if (rowcount > 0)
      printf("%d entr%s fixed\n", rowcount, rowcount==1?"y":"ies");
    else
      printf("Not fixed\n");
    modified("servers");
}


show_krb_usr(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int found = 1, id1;
    EXEC SQL END DECLARE SECTION; 
    struct string *s;
    char *ss;

    EXEC SQL DECLARE csr218 CURSOR FOR
	SELECT string_id FROM krbmap
	    WHERE users_id = :id ;
    EXEC SQL OPEN csr218;
    while(1) {
	EXEC SQL FETCH csr218 INTO :id1;
	if (sqlca.sqlcode != 0) break; 

	if (s = ((struct string *)hash_lookup(strings, id1)))
	    ss = s->name;
	else
	    ss = "[unknown]";
	found = 0;
	printf("Kerberos map for non-existant user %d to principal %s\n",
	       id, s);
    }
    EXEC SQL CLOSE csr218; 
    return(found);
}


show_krb_str(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int found = 1, id1;
    EXEC SQL END DECLARE SECTION; 
    struct user *u;
    char *s;

    EXEC SQL DECLARE csr219 CURSOR FOR
	SELECT users_id FROM krbmap
	    WHERE string_id = :id;
    EXEC SQL OPEN csr219;
    while(1) {
	EXEC SQL FETCH csr219 INTO :id1;
	if (sqlca.sqlcode != 0) break; 

	if (u = ((struct user *)hash_lookup(users, id1)))
	    s = u->login;
	else
	    s = "[\?\?\?]";
	found = 0;
	printf("Kerberos map for user %s (%d) to non-existant string %d\n",
	       s, id1, id);
	}
    EXEC SQL CLOSE csr219; 
    return(found);
}


show_pdm_mach(id)
EXEC SQL BEGIN DECLARE SECTION; 
int id;
EXEC SQL END DECLARE SECTION; 
{
    EXEC SQL BEGIN DECLARE SECTION; 
    char name[33];
    EXEC SQL END DECLARE SECTION; 
    int found = 1;

    EXEC SQL DECLARE csr220 CURSOR FOR
	SELECT name FROM palladium
	    WHERE mach_id = :id;
    EXEC SQL OPEN csr220;
    while(1) {
	EXEC SQL FETCH csr220 INTO :name;
	if (sqlca.sqlcode != 0) break; 

	strtrim(name);
        printf("Palladium server/supervisor %s is on non-existant machine %d\n",
	       name, id);
	found = 0;
	}
    EXEC SQL CLOSE csr220; 
    return(found);
}


phase2()
{
    EXEC SQL BEGIN DECLARE SECTION; 
    int id1, id2, id3, id4, id5;
    char type[9], name[33];
    EXEC SQL END DECLARE SECTION; 
    struct save_queue *sq, *sq1, *sq2, *sq3, *sq4, *sq5;
    struct filesys *f;
    struct list *l;
    struct nfsphys *n;
    struct machine *m;

    printf("Phase 2 - Checking references\n");

    dprintf("Checking users...\n");
    hash_step(users, user_check, NULL);

    dprintf("Checking machines...\n");
    hash_step(machines, mach_check, NULL);

    dprintf("Checking subnets...\n");
    hash_step(subnets, subnet_check, NULL);

    dprintf("Checking clusters...\n");
    hash_step(clusters, cluster_check, NULL);

    dprintf("Checking mcmap...\n");
    sq1 = sq_create();
    sq2 = sq_create();
    EXEC SQL DECLARE csr221 CURSOR FOR
      SELECT mach_id, clu_id FROM mcmap;
    EXEC SQL OPEN csr221;
    while(1) {
	EXEC SQL FETCH csr221 INTO :id1, :id2;
	if (sqlca.sqlcode != 0) break; 

	if (!(m = (struct machine *)hash_lookup(machines, id1)))
	    sq_save_unique_data(sq1, id1);
	else if (!hash_lookup(clusters, id2))
	    sq_save_unique_data(sq2, id2);
	if (m) m->clucount++;
    }
    EXEC SQL CLOSE csr221; 
    generic_delete(sq1, show_mcm_mach, "mcmap", "mach_id", 1);
    generic_delete(sq2, show_mcm_clu, "mcmap", "clu_id", 1);

    dprintf("Checking service clusters...\n");
    sq1 = sq_create();
    EXEC SQL DECLARE csr222 CURSOR FOR
      SELECT clu_id FROM svc;
    EXEC SQL OPEN csr222;
    while(1) {
	EXEC SQL FETCH csr222 INTO :id1;
	if (sqlca.sqlcode != 0) break; 

    	if (!hash_lookup(clusters, id1))
	  sq_save_unique_data(sq1, id1);
    }
    EXEC SQL CLOSE csr222; 
    generic_delete(sq1, show_svc, "svc", "clu_id", 1);

    dprintf("Checking lists...\n");
    hash_step(lists, list_check, NULL);

    dprintf("Checking members...\n");
    sq1 = sq_create();
    sq2 = sq_create();
    sq3 = sq_create();
    sq4 = sq_create();
    sq5 = sq_create();

    EXEC SQL DECLARE csr223 CURSOR FOR
      SELECT list_id, member_type, member_id, ref_count, direct
      FROM imembers FOR UPDATE OF member_id;
    EXEC SQL OPEN csr223;
    while(1) {
	EXEC SQL FETCH csr223 INTO :id1, :type, :id2, :id3, :id4;
	if (sqlca.sqlcode != 0) break; 

	if ((l = (struct list *) hash_lookup(lists, id1)) == NULL)
	  sq_save_unique_data(sq1, id1);
	else if (type[0] == 'U' && !hash_lookup(users, id2))
	  sq_save_unique_data(sq2, id2);
	else if (type[0] == 'L' && !hash_lookup(lists, id2))
	  sq_save_unique_data(sq3, id2);
	else if (type[0] == 'S' && !maybe_fixup_unref_string2("imembers","member_id","csr223",id2))
	  sq_save_unique_data(sq4, id2);
	else if (type[0] == 'K' && !maybe_fixup_unref_string2("imembers","member_id","csr223",id2))
	  sq_save_unique_data(sq5, id2);
	else
	  l->members++;
	}
    EXEC SQL CLOSE csr223; 
    generic_delete(sq1, show_member_list, "imembers", "list_id", 1);
    generic_fix(sq2, show_mem_user, "Delete", del_mem_user, 1);
    generic_fix(sq3, show_mem_list, "Delete", del_mem_list, 1);
    generic_fix(sq4, show_mem_str, "Delete", del_mem_str, 1);
    generic_fix(sq5, show_mem_krb, "Delete", del_mem_krb, 1);

    dprintf("Checking servers...\n");
    sq1 = sq_create();
    sq2 = sq_create();
    EXEC SQL DECLARE csr224 CURSOR FOR
      SELECT name, acl_type, acl_id, modby FROM servers
      FOR UPDATE of modby;
    EXEC SQL OPEN csr224;
    while(1) {
	EXEC SQL FETCH csr224 INTO :name, :type, :id1, :id2;
	if (sqlca.sqlcode != 0) break; 

	maybe_fixup_modby2("servers","modby","csr224",id2);
	strtrim(type);
	if (!strcmp(type, "USER") && !hash_lookup(users, id1)) {
	    sq_save_data(sq1, id1);
	} else if (!strcmp(type, "LIST") && !hash_lookup(lists, id1)) {
	    sq_save_data(sq2, id1);
	}
    }
    EXEC SQL CLOSE csr224; 
    generic_fix(sq1, show_srv_user, "Fix", zero_srv_user, 1);
    generic_fix(sq2, show_srv_list, "Fix", zero_srv_list, 1);

    dprintf("Checking serverhosts...\n");
    sq = sq_create();
    EXEC SQL DECLARE csr225 CURSOR FOR
      SELECT mach_id, modby FROM serverhosts
      FOR UPDATE OF modby;
    EXEC SQL OPEN csr225;
    while(1) {
	EXEC SQL FETCH csr225 INTO :id1, :id2;
	if (sqlca.sqlcode != 0) break; 

	maybe_fixup_modby2("serverhosts", "modby", "csr225", id2);
    	if (!hash_lookup(machines, id1))
	  sq_save_data(sq, id1);
	}
    EXEC SQL CLOSE csr225; 
    generic_fix(sq, show_sh, "Delete", del_sh_mach, 0);

    dprintf("Checking nfsphys...\n");
    hash_step(nfsphys, check_nfsphys, NULL);

    dprintf("Checking filesys...\n");
    hash_step(filesys, check_fs, NULL);

    dprintf("Checking filesystem groups...\n");
    sq1 = sq_create();
    sq2 = sq_create();
    sq3 = sq_create();
    EXEC SQL DECLARE csr226 CURSOR FOR
      SELECT group_id, filsys_id FROM fsgroup;
    EXEC SQL OPEN csr226;
    while(1) {
	EXEC SQL FETCH csr226 INTO :id1, :id2;
	if (sqlca.sqlcode != 0) break; 

    	if (!(f = (struct filesys *) hash_lookup(filesys, id1)))
	  sq_save_data(sq1, id1);
    	if (!hash_lookup(filesys, id2))
	  sq_save_data(sq3, id2);
    }
    EXEC SQL CLOSE csr226; 
    generic_delete(sq1, show_fsg_missing, "fsgroup", "group_id", 0);
    generic_delete(sq3, show_fsg_nomember, "fsgroup", "filsys_id", 1);

    dprintf("Checking quotas...\n");
    sq1 = sq_create();
    sq2 = sq_create();
    sq3 = sq_create();
    sq4 = sq_create();
    EXEC SQL DECLARE csr227 CURSOR FOR
      SELECT entity_id, type, filsys_id, phys_id, quota, modby
      FROM quota FOR UPDATE OF modby;
    EXEC SQL OPEN csr227;
    while(1) {
	EXEC SQL FETCH csr227 INTO :id1, :type, :id2, :id3, :id4, :id5;
	if (sqlca.sqlcode != 0) break; 

	maybe_fixup_modby2("quota", "modby", "csr227", id5);
	if (type[0] == 'U' && id1 != 0 && !hash_lookup(users, id1))
	  sq_save_data(sq1, id1);
	else if (type[0] == 'G' && !hash_lookup(lists, id1))
	  sq_save_data(sq4, id1);
	else if (!(f = (struct filesys *) hash_lookup(filesys, id2)))
	  sq_save_data(sq2, id2);
	else if (id3 != f->phys_id ||
	    ((n = (struct nfsphys*) hash_lookup(nfsphys, id3)) ==
	    (struct nfsphys *)NULL))
	  sq_save_data(sq3, id2);
	else
	  n->count += id4;
    }
    EXEC SQL CLOSE csr227; 
    generic_fix(sq1, show_quota_nouser, "Delete", fix_quota_nouser, 1);
    generic_fix(sq2, show_quota_nofs, "Delete", fix_quota_nofs, 0);
    generic_fix(sq3, show_quota_wrongpid, "Fix", fix_quota_physid, 1);
    generic_fix(sq4, show_quota_nolist, "Delete", fix_quota_nolist, 1);

    dprintf("Not checking zephyr.\n");

    dprintf("Checking hostaccess...\n");
    EXEC SQL DECLARE csr228 CURSOR FOR
      SELECT mach_id, acl_type, acl_id, modby FROM hostaccess
      FOR UPDATE OF modby;
    EXEC SQL OPEN csr228;
    while(1) {
	EXEC SQL FETCH csr228 INTO :id1, :type, :id2, :id3;
	if (sqlca.sqlcode != 0) break; 

	maybe_fixup_modby2("hostaccess", "modby", "csr228", id3);
	strtrim(type);
	if (!hash_lookup(machines, id1)) {
	    printf("Hostaccess for non-existant host %d\n", id1);
	    printf("Not fixing this error\n");
	}
	if (!strcmp(type, "USER") && !hash_lookup(users, id2)) {
	    printf("Hostaccess for %d is non-existant user %d\n", id1, id2);
	    printf("Not fixing this error\n");
	} else if (!strcmp(type, "LIST") && !hash_lookup(lists, id2)) {
	    printf("Hostaccess for %d is non-existant list %d\n", id1, id2);
	    printf("Not fixing this error\n");
	}
    }
    EXEC SQL CLOSE csr228; 

    dprintf("Checking palladium...\n");
    sq1 = sq_create();
    EXEC SQL DECLARE csr229 CURSOR FOR
      SELECT mach_id, modby FROM palladium
      FOR UPDATE OF modby;
    EXEC SQL OPEN csr229;
    while(1) {
	EXEC SQL FETCH csr229 INTO :id1, :id2;
	if (sqlca.sqlcode != 0) break; 

	maybe_fixup_modby2("palladium", "modby", "csr229", id2);
	if (!hash_lookup(machines, id1)) {
	    sq_save_unique_data(sq1, id1);
	}
    }
    EXEC SQL CLOSE csr229;
    generic_delete(sq1, show_pdm_mach, "palladium", "mach_id", 1);

    dprintf("Checking krbmap...\n");
    sq1 = sq_create();
    sq2 = sq_create();
    EXEC SQL DECLARE csr230 CURSOR FOR
      SELECT users_id, string_id FROM krbmap
      FOR UPDATE OF string_id;
    EXEC SQL OPEN csr230;
    while(1) {
	EXEC SQL FETCH csr230 INTO :id1, :id2;
	if (sqlca.sqlcode != 0) break; 

    	if (!hash_lookup(users, id1))
	  sq_save_unique_data(sq1, id1);
	else if (!maybe_fixup_unref_string2("krbmap","string_id","csr230",id2))
	  sq_save_unique_data(sq2, id2);
	}
    EXEC SQL CLOSE csr230; 
    generic_delete(sq1, show_krb_usr, "krbmap", "users_id", 1);
    generic_delete(sq2, show_krb_str, "krbmap", "string_id", 1);

    dprintf("Checking capacls...\n");
    EXEC SQL DECLARE csr231 CURSOR FOR
      SELECT list_id, tag FROM capacls;
    EXEC SQL OPEN csr231;
    while(1) {
	EXEC SQL FETCH csr231 INTO :id1, :name;
	if (sqlca.sqlcode != 0) break; 

	if (!hash_lookup(lists, id1)) {
	    printf("Capacl for %s is non-existant list %d\n", name, id1);
	    printf("Not fixing this error\n");
	}
    }
    EXEC SQL CLOSE csr231;

    dprintf("Checking hostaliases\n");
    sq1 = sq_create();
    EXEC SQL DECLARE csr232 CURSOR FOR
      SELECT mach_id FROM hostalias;
    EXEC SQL OPEN csr232;
    while(1) {
	EXEC SQL FETCH csr232 INTO :id1;
	if (sqlca.sqlcode != 0) break; 

	if (!hash_lookup(machines, id1))
	  sq_save_unique_data(sq1, id1);
    }
    EXEC SQL CLOSE csr232;
    generic_delete(sq1, show_hostalias, "hostalias", "mach_id", 1);
    
    dprintf("Checking printcaps\n");
    sq1 = sq_create();
    sq2 = sq_create();
    EXEC SQL DECLARE csr233 CURSOR FOR
      SELECT mach_id, quotaserver, modby FROM printcap;
    EXEC SQL OPEN csr233;
    while(1) {
	EXEC SQL FETCH csr233 INTO :id1, :id2, :id3;
	if (sqlca.sqlcode != 0) break; 

	maybe_fixup_modby2("printcap", "modby", "csr233", id3);
	if (!hash_lookup(machines, id1))
	  sq_save_unique_data(sq1, id1);
	else if(!hash_lookup(machines, id2))
	  sq_save_unique_data(sq2, id2);
    }
    EXEC SQL CLOSE csr233;
    generic_delete(sq1, show_pcap_mach, "printcap", "mach_id", 1);
    generic_delete(sq2, show_pcap_quota, "printcap", "quotaserver", 1);
}
