/* $Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/db/newmoira.dc,v 1.5 1993-10-25 16:51:54 mar Exp $
 *
 * Creates a new sms database
 *
 * Copyright 1988 by the Massachusetts Institute of Technology.
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
 */

#include <mit-copyright.h>
#include <stdio.h>
#include "../server/query.h"
EXEC SQL INCLUDE sqlca;

extern char *tables[];
extern struct query Queries2[];
extern int QueryCount2;

char *values[] = { "users_id", "mach_id", "clu_id", "list_id",
		   "nfsphys_id", "filsys_id", "strings_id", "dcm_enable",
		   0 };

struct alias { char *name;
	       char *type;
	       char *trans;
	   } aliases[] = {
		   {"ace_type", "TYPE", "KERBEROS"},
		   {"ace_type", "TYPE", "LIST"},
		   {"ace_type", "TYPE", "NONE"},
		   {"ace_type", "TYPE", "USER"},
		   {"alias", "TYPE", "FILESYS"},
		   {"alias", "TYPE", "PALLADIUM"},
		   {"alias", "TYPE", "TYPE"},
		   {"alias", "TYPE", "SERVICE"},
		   {"alias", "TYPE", "TYPEDATA"},
		   {"alias", "TYPE", "VALUE"},
		   {"boolean", "TYPE", "FALSE"},
		   {"boolean", "TYPE", "DONTCARE"},
		   {"boolean", "TYPE", "TRUE"},
		   {"class", "TYPE", "STAFF"},
		   {"class", "TYPE", "1990"},
		   {"class", "TYPE", "1991"},
		   {"class", "TYPE", "1992"},
		   {"class", "TYPE", "1993"},
		   {"class", "TYPE", "FACULTY"},
		   {"class", "TYPE", "G"},
		   {"class", "TYPE", "GUEST"},
		   {"class", "TYPE", "TEST"},
		   {"class", "TYPE", "SYSTEM"},
		   {"filesys", "TYPE", "ERR"},
		   {"filesys", "TYPE", "FSGROUP"},
		   {"filesys", "TYPE", "NFS"},
		   {"filesys", "TYPE", "RVD"},
		   {"filesys", "TYPE", "AFS"},
		   {"fs_access_AFS", "TYPE", "w"},
		   {"fs_access_AFS", "TYPE", "n"},
		   {"fs_access_NFS", "TYPE", "r"},
		   {"fs_access_NFS", "TYPE", "n"},
		   {"fs_access_NFS", "TYPE", "w"},
		   {"fs_access_RVD", "TYPE", "r"},
		   {"fs_access_RVD", "TYPE", "x"},
		   {"gaus", "TYPE", "LIST"},
		   {"gaus", "TYPE", "USER"},
		   {"gaus", "TYPE", "RLIST"},
		   {"gaus", "TYPE", "RUSER"},
		   {"lockertype", "TYPE", "COURSE"},
		   {"lockertype", "TYPE", "HOMEDIR"},
		   {"lockertype", "TYPE", "OTHER"},
		   {"lockertype", "TYPE", "PROJECT"},
		   {"lockertype", "TYPE", "SYSTEM"},
		   {"mac_type", "TYPE", "MAC"},
		   {"mac_type", "TYPE", "NEXT"},
		   {"mac_type", "TYPE", "PMAX"},
		   {"mac_type", "TYPE", "RT"},
		   {"mac_type", "TYPE", "VAX"},
		   {"member", "TYPE", "KERBEROS"},
		   {"member", "TYPE", "LIST"},
		   {"member", "TYPE", "STRING"},
		   {"member", "TYPE", "USER"},
		   {"pobox", "TYPE", "SMTP"},
		   {"pobox", "TYPE", "NONE"},
		   {"pobox", "TYPE", "POP"},
		   {"quota_type", "TYPE", "USER"},
		   {"quota_type", "TYPE", "GROUP"},
		   {"quota_type", "TYPE", "ANY"},
		   {"rmember", "TYPE", "LIST"},
		   {"rmember", "TYPE", "STRING"},
		   {"rmember", "TYPE", "USER"},
		   {"rmember", "TYPE", "KERBEROS"},
		   {"rmember", "TYPE", "RLIST"},
		   {"rmember", "TYPE", "RSTRING"},
		   {"rmember", "TYPE", "RUSER"},
		   {"rmember", "TYPE", "RKERBEROS"},
		   {"service", "TYPE", "REPLICAT"},
		   {"service", "TYPE", "REPLICATED"},
		   {"service", "TYPE", "UNIQUE"},
		   {"slabel", "TYPE", "LPR"},
		   {"slabel", "TYPE", "KERBEROS"},
		   {"slabel", "TYPE", "USRLIB"},
		   {"slabel", "TYPE", "SYSLIB"},
		   {"slabel", "TYPE", "ZEPHYR"},
		   {"ANY", "TYPEDATA", "none"},
		   {"KERBEROS", "TYPEDATA", "string"},
		   {"GROUP", "TYPEDATA", "list"},
		   {"LIST", "TYPEDATA", "list"},
		   {"NONE", "TYPEDATA", "none"},
		   {"POP", "TYPEDATA", "machine"},
		   {"RLIST", "TYPEDATA", "list"},
		   {"RSTRING", "TYPEDATA", "string"},
		   {"RUSER", "TYPEDATA", "user"},
		   {"SMTP", "TYPEDATA", "string"},
		   {"STRING", "TYPEDATA", "string"},
		   {"USER", "TYPEDATA", "user"},	
		   0 };


int ingres_errno = 0;

main(argc, argv)
int argc;
char **argv;
{
    EXEC SQL BEGIN DECLARE SECTION;
    char buffer[256];
    char *db, *tbl, *value, *user, *query, *trans, *type;
    int i, list;
    char stmt_buf[256];
    EXEC SQL END DECLARE SECTION;

    if (argc == 2)
      db = argv[1];
    else
      db = "sms";
#ifsql INGRES
    EXEC SQL CONNECT :db;
#endsql
#ifsql INFORMIX
    EXEC SQL DATABASE db;
#endsql
    EXEC SQL WHENEVER SQLERROR CALL ingerr;

    strcpy(buffer, "root");
    user = buffer;
    while (buffer[0]) {
	for (i = 0; tbl = tables[i]; i++) {
#ifsql INGRES
	    sprintf(stmt_buf,"GRANT ALL PRIVILEGES ON TABLE %s TO %s",tbl,user);
	    EXEC SQL EXECUTE IMMEDIATE :stmt_buf;
#endsql
	    if (ingres_errno) {
		printf("Unable to give %s permission to access table %s\n",
		       user, tbl);
		exit(1);
	    }
	}
	printf("Enter the name of another user to be given direct access to\n");
	printf("the database, or [RETURN] if none: ");
	fflush(stdout);
	gets(user);
    }

    for (i = 0; tbl = tables[i]; i++) {
	EXEC SQL INSERT INTO tblstats
	  (table_name, modtime, appends, updates, deletes)
	  VALUES (:tbl, 'now', 0, 0, 0);
	if (ingres_errno) {
	    printf("Unable to initialize tblstats for %s\n", tbl);
	    EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	    printf("SQL error: %s\n",buffer);
	    exit(1);
	}
    }

    for (i = 0; value = values[i]; i++) {
	EXEC SQL INSERT INTO numvalues (name, value)
	  VALUES (:value, 1);
	if (ingres_errno) {
	    printf("Unable to install initial value of %s\n", value);
	    EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	    printf("SQL error: %s\n",buffer);
	    exit(1);
	}
    }

    printf("What is the starting UID to assign: ");
    fflush(stdout);
    gets(buffer);
    i = atoi(buffer);
    EXEC SQL INSERT INTO numvalues (name, value)
      VALUES ('uid', :i);
    if (ingres_errno) {
	printf("Unable to install value for uid\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }

    printf("What is the starting GID to assign: ");
    fflush(stdout);
    gets(buffer);
    i = atoi(buffer);
    EXEC SQL INSERT INTO numvalues (name, value)
      VALUES ('gid', :i);
    if (ingres_errno) {
	printf("Unable to install value for gid\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }

    printf("What is the default NFS quota to assign: ");
    fflush(stdout);
    gets(buffer);
    i = atoi(buffer);
    EXEC SQL INSERT INTO numvalues (name, value)
      VALUES ('def_quota', :i);
    if (ingres_errno) {
	printf("Unable to install value for def_quota\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);	
	exit(1);
    }

    /* place holder records */
    EXEC SQL INSERT INTO users (login, potype, users_id)
      VALUES ('[nobody]', 'NONE', 0);
    if (ingres_errno) {
	printf("Unable to install 0 user\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }
    EXEC SQL INSERT INTO machine (name, type)
      VALUES ('[NONE]', 'NONE');
    if (ingres_errno) {
	printf("Unable to install 0 machine\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }
    EXEC SQL INSERT INTO cluster (name)
      VALUES ('[unassigned]');
    if (ingres_errno) {
	printf("Unable to install 0 cluster\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }
    EXEC SQL INSERT INTO list (name, acl_type)
      VALUES ('[none]', 'NONE');
    if (ingres_errno) {
	printf("Unable to install 0 list\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }
    EXEC SQL INSERT INTO filesys (label, type)
      VALUES ('[none]', 'NONE');
    if (ingres_errno) {
	printf("Unable to install 0 filesys\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }
    EXEC SQL INSERT INTO nfsphys (device)
      VALUES ('/dev/null');
    if (ingres_errno) {
	printf("Unable to install 0 nfsphys\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }

    /* magic for ALL_USERS */
    EXEC SQL INSERT INTO users (login, users_id, potype)
      VALUES ('default', 1, 'NONE');
    if (ingres_errno) {
	printf("Unable to install default user\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }
    EXEC SQL INSERT INTO list (name, list_id, acl_type)
      VALUES ('default', 1, 'NONE');
    if (ingres_errno) {
	printf("Unable to install default list\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }
    EXEC SQL INSERT INTO imembers
      (list_id, member_type, member_id, ref_count, direct)
      VALUES (1, 'USER', 1, 1, 1);
    if (ingres_errno) {
	printf("Unable to install default user on default list\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }

    /* Privileged users */
    EXEC SQL INSERT INTO users (login, users_id, potype)
      VALUES ('root', 2, 'NONE');
    if (ingres_errno) {
	printf("Unable to install root user\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }
    EXEC SQL INSERT INTO list (name, list_id, acl_type, acl_id)
      VALUES ('dbadmin', 2, 'LIST', 2);
    if (ingres_errno) {
	printf("Unable to install default dbadmin list\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }

    printf("What is the name of a privileged user: ");
    fflush(stdout);
    gets(buffer);
    user = buffer;
    EXEC SQL INSERT INTO users (login, users_id, potype)
      VALUES (:user, 3, 'NONE');
    if (ingres_errno) {
	printf("Unable to install user %s\n", buffer);
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }
    EXEC SQL INSERT INTO imembers
      (list_id, member_type, member_id, ref_count, direct)
      VALUES (2, 'USER', 2, 1, 1);
    if (ingres_errno) {
	printf("Unable to put user root on list dbadmin\n");
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }
    EXEC SQL INSERT INTO imembers
      (list_id, member_type, member_id, ref_count, direct)
      VALUES (2, 'USER', 3, 1, 1);
    if (ingres_errno) {
	printf("Unable to put user %s on list dbadmin\n", buffer);
	EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	printf("SQL error: %s\n",buffer);
	exit(1);
    }

    /* And the capacls */
    for (i = 0; i < QueryCount2; i++) {
	query = Queries2[i].name;
	value = Queries2[i].shortname;
	list = 2;
	if (!strcmp(value, "gali") || !strcmp(value, "glig") ||
	    !strcmp(value, "glim") || !strcmp(value, "gval"))
	  list = 1;
	EXEC SQL INSERT INTO capacls (capability, tag, list_id)
	  VALUES (:query, :value, :list);
	if (ingres_errno) {
	    printf("Unable to install query ACL for %s (%s)\n", query, value);
	    EXEC SQL INQUIRE_SQL (:buffer = ERRORTEXT);
	    printf("SQL error: %s\n",buffer);
	    exit(1);
	}
    }
    EXEC SQL INSERT INTO capacls (capability, tag, list_id)
      VALUES ('trigger_dcm', 'tdcm', 2);

    /* and the aliases */
    for (i = 0; aliases[i].name ; i++) {
	value = aliases[i].name;
	type = aliases[i].type;
	trans = aliases[i].trans;
	EXEC SQL INSERT INTO alias (name, type, trans)
	  VALUES (:value, :type, :trans);
    }

    printf("\nNow committing work... ");
#ifsql INGRES
    EXEC SQL COMMIT WORK;
#endsql

    printf("done.\n");
    exit(0);
}


/*
 * ingerr: (supposedly) called when Ingres indicates an error.
 * I have not yet been able to get this to work to intercept a
 * database open error.
 */

int ingerr()
{
    ingres_errno = -sqlca.sqlcode;
    return ingres_errno;
}


/* dummy routines */
int access_user() {}
int access_login() {}
int access_list() {}
int access_visible_list() {}
int access_vis_list_by_name() {}
int access_member() {}
int access_qgli() {}
int access_service() {}
int access_filesys() {}
int setup_ausr() {}
int setup_dusr() {}
int setup_spop() {}
int setup_dpob() {}
int setup_dmac() {}
int setup_dclu() {}
int setup_alis() {}
int setup_dlis() {}
int setup_dsin() {}
int setup_dshi() {}
int setup_afil() {}
int setup_ufil() {}
int setup_dfil() {}
int setup_dnfp() {}
int setup_dqot() {}
int setup_sshi() {}
int setup_akum() {}
int followup_fix_modby() {}
int followup_ausr() {}
int followup_gpob() {}
int followup_glin() {}
int followup_aqot() {}
int followup_gzcl() {}
int followup_gsha() {}
int followup_gqot() {}
int set_modtime() {}
int set_modtime_by_id() {}
int set_finger_modtime() {}
int set_pobox_modtime() {}
int set_uppercase_modtime() {}
int set_mach_modtime_by_id() {}
int set_cluster_modtime_by_id() {}
int set_serverhost_modtime() {}
int set_nfsphys_modtime() {}
int set_filesys_modtime() {}
int set_zephyr_modtime() {}
int set_pobox() {}
int get_list_info() {}
int add_member_to_list() {}
int delete_member_from_list() {}
int get_ace_use() {}
int qualified_get_lists() {}
int get_members_of_list() {}
int qualified_get_server() {}
int qualified_get_serverhost() {}
int trigger_dcm() {}
int count_members_of_list() {}
int get_lists_of_member() {}
int register_user() {}
int followup_gpce() {}
int prefetch_value() {}
int prefetch_filesys() {}
int followup_dqot() {}
int followup_guax() {}
int followup_uuac() {}
int get_end_members_of_list() {}
int _sdl_followup() {}
