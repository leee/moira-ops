/*
 *	$Source: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/backup/dump_db.pc,v $
 *	$Author: danw $
 *	$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/backup/dump_db.pc,v 1.5 1998-01-07 17:12:39 danw Exp $
 *
 *	(c) Copyright 1988 by the Massachusetts Institute of Technology.
 *	For copying and distribution information, please see the file
 *	<mit-copyright.h>.
 *
 * 	This program dumps the Moira database to a series of output files
 * which can be later read back into Moira in the event of a crash.
 *
 */

#ifndef lint
static char *rcsid_dump_db_c = "$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/backup/dump_db.pc,v 1.5 1998-01-07 17:12:39 danw Exp $";
#endif lint

#include <stdio.h>
#include <sys/file.h>
#include <fcntl.h>
#include <ctype.h>
#include <mit-copyright.h>
EXEC SQL INCLUDE sqlca;
#include "dump_db.h"

/* putc without the line buffer hair */

#define putc1(x, p)	(--(p)->_cnt >= 0 ?\
	(int)(*(unsigned char *)(p)->_ptr++ = (x)) :\
		_flsbuf((unsigned char)(x), p))

FILE *open_file();

EXEC SQL BEGIN DECLARE SECTION;
char *db = "moira";
EXEC SQL END DECLARE SECTION;

int main(int argc, char **argv)
{
  char *prefix;
  int i;

  if (argc != 2)
    {
      fprintf(stderr, "Usage: %s prefix\n", argv[0]);
      exit(1);
    }
  prefix = argv[1];

  EXEC SQL CONNECT :db IDENTIFIED BY :db;

  do_backups(prefix);

  EXEC SQL COMMIT;
  exit(0);
}

int dump_int(FILE *f, int n)
{
  char buf[1024];
  sprintf(buf, "%d", n);
  dump_str(f, buf);
}

int wpunt(void)
{
  punt("can't write backup file");
}

int dump_str(FILE *f, char *str)
{
  char *ibp, c;
  int t;

  for (ibp = str; c = (unsigned char) *ibp; ibp++)
    {
      if (c < 32 || c > 126 || c == SEP_CHAR || c == '\\')
	{
	  if (putc1('\\', f) < 0)
	    wpunt();
	  t = ((c >> 6) & 7) + '0';
	  if (putc1(t, f) < 0)
	    wpunt();
	  t = ((c >> 3) & 7) + '0';
	  if (putc1(t, f) < 0)
	    wpunt();
	  t = (c & 7) + '0';
	  if (putc1(t, f) < 0)
	    wpunt();
	}
      else
	{
	  if (putc1(c, f) < 0)
	    wpunt();
	}
    }
}

int safe_close(FILE *stream)
{
  if (fflush(stream) == EOF)
    punt("Unable to fflush");
  if (fsync(fileno(stream)) != 0)
    punt("Unable to fsync");
  fclose(stream);
}

FILE *open_file(char *prefix, char *suffix)
{
  char name[BUFSIZ];
  int fd;
  FILE *f;

  strcpy(name, prefix);
  strcat(name, suffix);

  fd = open(name, O_CREAT|O_WRONLY|O_EXCL, 0644);
  if (fd < 0)
    punt(name);
  f = fdopen(fd, "w");
  if (!f)
    {
      fprintf(stderr, "fdopen of ");
      punt(name);
    }
  fprintf(stderr, "Working on %s\n", name);
  return f;
}


/*
 * Trim whitespace off both ends of a string.
 */
char *strtrim(char *save)
{
  char *t, *s;

  s = save;
  while (isspace(*s))
    s++;
  /* skip to end of string */
  if (*s == '\0')
    {
      *save = '\0';
      return save;
    }

  for (t = s; *t; t++)
    continue;
  while (t > s)
    {
      --t;
      if (!isspace(*t))
	{
	  t++;
	  break;
	}
    }
  *t = '\0';
  return s;
}
