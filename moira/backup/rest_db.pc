/*
 *	$Source: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/backup/rest_db.pc,v $
 *	$Author: danw $
 *	$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/backup/rest_db.pc,v 1.1 1997-01-29 22:57:41 danw Exp $
 *
 *  (c) Copyright 1988 by the Massachusetts Institute of Technology.
 *  For copying and distribution information, please see the file
 *  <mit-copyright.h>.
 * 
 */

#ifndef lint
static char *rcsid_rest_db_qc = "$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/backup/rest_db.pc,v 1.1 1997-01-29 22:57:41 danw Exp $";
#endif lint

#include <sys/file.h>
#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>
#include <mit-copyright.h>
EXEC SQL INCLUDE sqlca;
#include "dump_db.h"


/*ARGSUSED*/
main(argc, argv)
    int argc;
    char **argv;
{
    char buf[BUFSIZ];
    char *prefix;
    EXEC SQL BEGIN DECLARE SECTION;
    char *db;
    EXEC SQL END DECLARE SECTION;

    if (argc != 2) {
	fprintf(stderr, "Usage: %s database\n", argv[0]);
	exit(1);
    }
    db = argv[1];

    if (!yes_or_no("Do you *REALLY* want to wipe the moira database?")) {
	printf("I didn't think so\n");
	exit(1);
    }
    sprintf(buf, "Have you initialized an empty database named %s?", db);
    if (!yes_or_no(buf)) {
	printf("You should have\n");
	exit(1);
    }
    
    printf("Opening database: ");
    (void) fflush(stdout);
    EXEC SQL CONNECT :db IDENTIFIED BY :db;
    if (sqlca.sqlcode != 0) {
	com_err(argv[0], 0, "Ingres database open failed");
	exit(1);
    }
    printf(" done\n");

    printf("Prefix of backup to restore: ");
    (void) fflush(stdout);
    if (gets(buf) == NULL) {
	return 1;
    }
    prefix = buf;
    	
    if (!yes_or_no("Are you SURE?")) {
	printf("I didn't think so\n");
	exit(1);
    }
    do_restores(prefix);
    printf("Restore complete\n");
    EXEC SQL COMMIT;
    exit(0);
    /*NOTREACHED*/
}

yes_or_no(prompt)
    char *prompt;
{
    char buf[BUFSIZ];
    int ret;
    
    int tt = open("/dev/tty", O_RDWR, 0);
    FILE *o, *i;
    
    register char *cp;
    
    if (tt < 0) return 0;
    
    (void) fflush(stdout);
    (void) fflush(stderr);
    o = fdopen(dup(tt), "w");    
    i = fdopen(dup(tt), "r");
    (void) close(tt);    

    for (;;) {
	fprintf(o, "%s (yes or no): ", prompt);
	(void) fflush(o);
	if (fgets(buf, BUFSIZ, i) == NULL) goto err;
	for (cp = buf; *cp; cp++) {
	    if (isupper(*cp)) *cp=tolower(*cp);
	}
	if (strcmp(buf, "yes\n") == 0) {
	    ret = 1; goto out;
	}
	if (strcmp(buf, "no\n") == 0) {
	    ret = 0; goto out;
	}
    }

err:
    ret = 0;

out:
    (void) fclose(o);
    (void) fclose(i);
    return ret;
}

int parse_int(f)
    register FILE *f;
{
    register int c;
    register int val = 0;
    register int sign = 1;
    while ((c = getc(f)) != EOF && c != SEP_CHAR && c != '\n') {
	if (c == '-') sign = -1;
	else if (isdigit(c)) {
	    val *= 10;
	    val += (c - '0');
	} else (void) fprintf(stderr,"non-digit in numeric field\n");
    }
    (void) ungetc(c, f);
    return(val * sign);
}

void parse_str(f, buf, maxlen)
    register FILE *f;
    register char *buf;
    register int maxlen;
{
    register int c, len=0;

    while ((c = getc(f)) != EOF && c != SEP_CHAR && c != '\n' && len < maxlen) {
	if (c == '\\') {
	    c = getc(f);
	    if (isdigit(c)) {
		/* Expect three-digit octal number.. */
		register int c1, c2;
		c1 = getc(f);
		c2 = getc(f);
		if (!isdigit(c1) || !isdigit(c2)) 
		    punt("Broken \\###");
		/* Convert to ASCII code: */
		*buf++ =  (((c-'0')<<6) + ((c1-'0')<<3) + c2-'0');
		len++;
	    } else if (c == '\\' || c == SEP_CHAR) {
		*buf++ = c;
		len++;
	    } else punt ("Broken '\\'");
	} else {
	    *buf++ = c;
	    len++;
	}
    }
    *buf='\0';
    if (c == EOF)
	return;
    
    if (c != EOF && c != SEP_CHAR && c != '\n') {
	fprintf(stderr, "Field too wide, truncated\n");
	while ((c = getc(f)) != EOF && c != SEP_CHAR && c != '\n');
	(void) ungetc(c, f);
    } else {
	(void) ungetc(c, f);
    }
}
    
void parse_sep(f)
    FILE *f;
{
    if (getc(f) != SEP_CHAR) punt("Expected Separator");
}
void parse_nl(f)
    FILE *f;
{
    if (getc(f) != '\n') punt("Expected newline");
}


FILE *open_file(prefix, suffix)
    char *prefix, *suffix;
{
    char name[BUFSIZ];
    int fd;
    FILE *f;
    
    EXEC SQL COMMIT WORK;

    (void) strcpy(name, prefix);
    (void) strcat(name, suffix);

    fd = open(name, O_RDONLY, 0);
    if (fd < 0) {
	punt(name);
    }
    f = fdopen(fd, "r");
    if (f == NULL) {
	fprintf(stderr, "fdopen of ");
	punt(name);
    }
    fprintf(stderr, "Working on %s\n", name);
    return(f);
}
