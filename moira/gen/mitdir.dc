/* $Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/gen/mitdir.dc,v 1.1.1.1 1992-09-15 00:11:15 genoa Exp $
 *
 * This generates the input file for the mkdirdb program for the MIT.EDU
 * mailhub.
 *
 *  (c) Copyright 1989, 1990 by the Massachusetts Institute of Technology.
 *  For copying and distribution information, please see the file
 *  <mit-copyright.h>.
 */


#include <mit-copyright.h>
#include <stdio.h>
#include <string.h>
#include <moira.h>
#include <moira_site.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
EXEC SQL INCLUDE sqlca;


extern int errno;
char *whoami = "mitdir.gen";


main(argc, argv)
int argc;
char **argv;
{
    long tm = time(NULL);
    FILE *out= stdout;
    char filename[64], *targetfile;
    struct stat sb;
    EXEC SQL BEGIN DECLARE SECTION;
    int flag1;
    EXEC SQL END DECLARE SECTION;
    int ingerr();

    initialize_sms_error_table();

#ifsql INGRES
    EXEC SQL CONNECT moira;
#endsql
#ifsql INFORMIX
    EXEC SQL DATABASE moira;
#endsql

    if (argc == 2) {
	if (stat(argv[1], &sb) == 0) {
            if (ModDiff (&flag1, "users", sb.st_mtime))
	      exit(MR_DATE);
	    if (flag1 < 0) {
		fprintf(stderr, "File %s does not need to be rebuilt.\n",
			argv[1]);
		exit(MR_NO_CHANGE);
	    }
	}
	targetfile = argv[1];
	sprintf(filename, "%s~", targetfile);
	if ((out = fopen(filename, "w")) == NULL) {
	    fprintf(stderr, "unable to open %s for output\n", filename);
	    exit(MR_OCONFIG);
	}
    } else if (argc != 1) {
	fprintf(stderr, "usage: %s [outfile]\n", argv[0]);
	exit(MR_ARGS);
    }

    get_info(out);

#ifsql INGRES
    EXEC SQL DISCONNECT;
#endsql
#ifsql INFORMIX
    EXEC SQL CLOSE DATABASE;
#endsql

    if (fclose(out)) {
	perror("close failed");
	exit(MR_CCONFIG);
    }

    if (argc == 2)
      fix_file(targetfile);
    exit(MR_SUCCESS);
}


get_info(out)
FILE *out;
{
    int mitroom, mitphone;
    char stuemp, *mhost, *uname, *pob, *tmp;
    struct hash *strings;
    EXEC SQL BEGIN DECLARE SECTION;
    int id, pid, bid, mid;
    char name[129], type[9], buf[257], fname[17], mname[17], lname[17];
    char year[9], dept[13], oaddr[17], ophone[13], haddr[81], hphone[17];
    char affil[5];
    EXEC SQL END DECLARE SECTION;

    /* The following is declarative, not executed,
     * and so is dependent on where it is in the file,
     * not in the order of execution of statements.
     */
    EXEC SQL WHENEVER SQLERROR GOTO sqlerr;

    /* get locks */
    EXEC SQL SELECT modtime INTO :buf FROM users WHERE users_id = 0;

    strings = create_hash(2000);
    EXEC SQL DECLARE s_lock CURSOR FOR
      SELECT string_id, string
      FROM strings;
    EXEC SQL OPEN s_lock;
    while (1) {
	EXEC SQL FETCH s_lock INTO :id, :name;
	if (sqlca.sqlcode != 0) break;
	hash_store(strings, id, strsave(strtrim(name)));
    }
    EXEC SQL CLOSE s_lock;

    EXEC SQL DECLARE u_cursor1 CURSOR FOR
      SELECT users_id, login, first, middle, last,
	     affiliation, department, office_addr, office_phone,
	     home_addr, home_phone, potype, box_id
      FROM users
      WHERE status != 3;
    EXEC SQL OPEN u_cursor1;
    while (1) {
	EXEC SQL FETCH u_cursor1 INTO :id, :name, :fname, :mname, :lname, 
	          :year, :dept, :oaddr, :ophone, :haddr, :hphone, :type, :bid;
	if (sqlca.sqlcode != 0) break;

    	if (id == 0)
	  continue;

	strtrim(year);
	if (atoi(year) || !strcmp(year, "G"))
	  stuemp = 'S';
	else if (!strcmp(year, "FACULTY") || !strcmp(year, "MITS") ||
		 !strcmp(year, "STAFF"))
	  stuemp = 'E';
	else if (!strcmp(year, "PROJECT") || !strcmp(year, "SYSTEM"))
	  continue;
	else
	  stuemp = '?';

	if (type[0] == 'S' & (pob = hash_lookup(strings, bid)) != NULL) {
	    uname = pob;
	    mhost = index(pob, '@');
	    if (mhost)
	      *mhost++ = 0;
	    else
	      mhost = &uname[strlen(uname) + 1];
	} else if (type[0] == 'N') {
	    mhost = "";
	    uname = "";
	} else {
	    mhost = "ATHENA.MIT.EDU";
	    uname = strtrim(name);
	}

	strtrim(oaddr);
	if (oaddr[0] != ' ') {
	    tmp = &oaddr[strlen(oaddr) - 1];
	    if (*tmp == 'm' || *tmp == 'M') {
		*tmp = 0;
	    }
	  }

	if (tmp = index(ophone, '-')) {
	    bcopy(tmp+1, tmp, strlen(tmp)-1);
	}
	if (tmp = index(hphone, '-')) {
	    bcopy(tmp+1, tmp, strlen(tmp)-1);
	}

	fprintf(out, "%c:%s, %s %s:",
		stuemp, strtrim(lname), strtrim(fname), strtrim(mname));
	fprintf(out, "%s:%s:%s:%s::", lname, fname, mname, oaddr);
	if (ophone[0] != ' ')
	  fprintf(out, "%010d:::%s:%s:%s:",
		  atoi(ophone), strtrim(dept), uname, mhost);
	else
	  fprintf(out, ":::%s:%s:%s:",
		  strtrim(dept), uname, mhost);
	if (hphone[0] != ' ')
	  fprintf(out, "%s:::::%010d::::%s::0\n",
		  strtrim(haddr), atoi(hphone), year);
	else
	  fprintf(out, "%s:::::::::%s::0\n",
		  strtrim(haddr), year);
      }
    EXEC SQL CLOSE u_cursor1;
    return;
 sqlerr:
    com_err(whoami, MR_INGRES_ERR, " code %d\n", sqlca.sqlcode);
    critical_alert("DCM", "Mitdir build encountered INGRES ERROR %d",
		   sqlca.sqlcode);
    exit(MR_INGRES_ERR);
}
