/* $Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/gen/ca.dc,v 1.4 1993-02-24 15:59:12 mar Exp $
 *
 * This generates a list of users and their home directories for the
 * Centra America daemon.
 *
 *  (c) Copyright 1991 by the Massachusetts Institute of Technology.
 *  For copying and distribution information, please see the file
 *  <mit-copyright.h>.
 */

#include <mit-copyright.h>
#include <stdio.h>
#include <moira.h>
#include <moira_site.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <strings.h>
EXEC SQL INCLUDE sqlca;

extern int errno;
char *whoami = "ca.gen";

struct prec {
    int phys_id;
    char mach[64];
    char dir[128];
};


main(argc, argv)
int argc;
char **argv;
{
    FILE *out = stdout;
    char *outf = NULL, outft[64], *p, last[256];
    struct stat sb;
    struct save_queue *sq;
    struct prec *prec;
    int flag1, flag2, first, cnt;
    EXEC SQL BEGIN DECLARE SECTION;
    char login[257], name[257], dir[257];
    int id;
    EXEC SQL END DECLARE SECTION;

    initialize_sms_error_table ();

#ifsql INGRES
    EXEC SQL CONNECT moira;
    EXEC SQL SET LOCKMODE SESSION WHERE LEVEL=TABLE, READLOCK=SHARED;
#endsql
#ifsql INFORMIX
    EXEC SQL DATABASE moira;
#endsql

    if (argc == 2) {
	if (stat(argv[1], &sb) == 0) {
	    if (ModDiff (&flag1, "users", sb.st_mtime) == 0 &&
		ModDiff (&flag2, "filesys", sb.st_mtime) == 0 &&
		flag1 < 0 && flag2 < 0) {
		fprintf(stderr, "File %s does not need to be rebuilt.\n",
			argv[1]);
		exit(MR_NO_CHANGE);
	    }
	}
	outf = argv[1];
	sprintf(outft, "%s~", outf);
	if ((out = fopen(outft, "w")) == NULL) {
	    fprintf(stderr, "unable to open %s for output\n", outf);
	    exit(MR_OCONFIG);
	}
    } else if (argc != 1) {
	fprintf(stderr, "usage: %s [outfile]\n", argv[0]);
	exit(MR_ARGS);
    } else {
	outf = NULL;
    }

    EXEC SQL WHENEVER SQLERROR GOTO sqlerr;
    sq = sq_create();

    cnt = 0;
    EXEC SQL DECLARE y CURSOR FOR
      SELECT p.nfsphys_id, p.dir, m.name
      FROM nfsphys p, machine m
      WHERE m.mach_id = p.mach_id
      ORDER BY p.nfsphys_id;
    EXEC SQL OPEN y;
    while (1) {
	EXEC SQL FETCH y INTO :id, :dir, :name;
	if (sqlca.sqlcode != 0) break;
	if (id == 0) continue;
	strtrim(dir);
	strtrim(name);
	prec = (struct prec *) malloc(sizeof(struct prec));
	prec->phys_id = id;
	strcpy(prec->mach, strtrim(name));
	strcpy(prec->dir, strtrim(dir));
	sq_save_data(sq, prec);
	cnt++;
    }
    EXEC SQL CLOSE y;
    fprintf(stderr, "Loaded %d NFS partitions\n", cnt);

    while (sq_get_data(sq, &prec)) {
	id = prec->phys_id;
#ifdef DEBUG
	printf("got ID %d\n", id);
	printf("mach %s dir %s\n", prec->mach, prec->dir);
#endif
	EXEC SQL DECLARE x CURSOR FOR 
	  SELECT u.login, u.fullname
	  FROM users u, filesys f
	  WHERE f.label = u.login and u.status = 1 and f.phys_id = :id
	  ORDER BY u.login;
	EXEC SQL OPEN x;
	first = 1;
	while (1) {
	    EXEC SQL FETCH x INTO :login, :name;
	    if (sqlca.sqlcode != 0) break;
	    if (first) {
		first = 0;
		fprintf(out, "*%s:%s\n", prec->mach, prec->dir);
	    }
	    strtrim(login);
	    strtrim(name);
	    fprintf(out, "%s,%s\n", login, name);
	}
	EXEC SQL CLOSE x;
    }
    fprintf(stderr, "Processed NFS partitions\n");

    cnt = 0;
    EXEC SQL DECLARE z CURSOR FOR 
      SELECT DISTINCT u.login, u.fullname, f.name
      FROM users u, filesys f
      WHERE f.label = u.login and u.status = 1 and f.type = 'AFS'
      ORDER BY u.login;
    EXEC SQL OPEN z;
    while (1) {
	EXEC SQL FETCH z INTO :login, :name, :dir;
	if (sqlca.sqlcode != 0) break;
	p = rindex(dir, '/');
	if (p) *p = 0;
	if (strcmp(last, dir)) {
	    strcpy(last, dir);
	    fprintf(out, "*%s:%s\n", "AFS", dir);
	}
	strtrim(login);
	strtrim(name);
	fprintf(out, "%s,%s\n", login, name);
	cnt++;
    }
    EXEC SQL CLOSE z;
    fprintf(stderr, "Processed %d AFS users\n", cnt);

#ifsql INGRES
    EXEC SQL DISCONNECT;
#endsql
#ifsql INFORMIX
    EXEC SQL CLOSE DATABASE;
#endsql

    if (fclose(out)) {
	perror("close failed");
	exit(MR_CCONFIG);
    }
    if (outf)
      fix_file(outf);
    exit(MR_SUCCESS);

 sqlerr:
    com_err(whoami, MR_INGRES_ERR, " code %d\n", sqlca.sqlcode);
#ifsql INGRES
    if (sqlca.sqlcode == 17700)
      exit(MR_DEADLOCK);
#endsql
    critical_alert("DCM", "Central America build encountered INGRES ERROR %d",
		   sqlca.sqlcode);
    exit(MR_INGRES_ERR);
}
