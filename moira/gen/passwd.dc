/* $Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/gen/passwd.dc,v 1.9 1990-03-19 19:07:32 mar Exp $
 *
 * This generates a master /etc/passwd containing all active (status != 0)
 * accounts.
 *
 *  (c) Copyright 1988 by the Massachusetts Institute of Technology.
 *  For copying and distribution information, please see the file
 *  <mit-copyright.h>.
 */

#include <mit-copyright.h>
#include <stdio.h>
#include <moira.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>

extern int errno;
char *ingres_date_and_time();
char *whoami = "passwd.gen";


main(argc, argv)
int argc;
char **argv;
{
    FILE *out = stdout;
    char *outf, outft[64];
    struct stat sb;
##  char login[9], shell[33], fullname[33], oa[17], op[13], hp[17], *filetime;
##  char nickname[17];
##  int uid, error, flag;
    int ingerr();

    IIseterr(ingerr);
##  ingres sms
##  set lockmode session where level = table

    if (argc == 2) {
	if (stat(argv[1], &sb) == 0) {
	    filetime = ingres_date_and_time(sb.st_mtime);
##	    retrieve (flag = int4(interval("min", tblstats.modtime - filetime)))
##		where tblstats.table = "users"
	    if (flag < 0) {
		fprintf(stderr, "File %s does not need to be rebuilt.\n",
			argv[1]);
		exit(MR_NO_CHANGE);
	    }
	}
	outf = argv[1];
	sprintf(outft, "%s~", outf);
	if ((out = fopen(outft, "w")) == NULL) {
	    fprintf(stderr, "unable to open %s for output\n", outf);
	    exit(MR_OCONFIG);
	}
    } else if (argc != 1) {
	fprintf(stderr, "usage: %s [outfile]\n", argv[0]);
	exit(MR_ARGS);
    } else {
	outf = NULL;
    }

##  range of u is users
##  retrieve (login = u.#login, uid = u.#uid, shell = u.#shell,
##	      fullname = u.#fullname, oa = u.office_addr,
##	      nickname = u.#nickname,
##	      op = u.office_phone, hp = u.home_phone)
##	where u.status = 1 {
	    strtrim(login);
	    strtrim(fullname);
	    strtrim(nickname);
	    strtrim(oa);
	    strtrim(op);
	    strtrim(hp);
	    strtrim(shell);
    	    fprintf(out, "%s:*:%d:101:%s,%s,%s,%s,%s:/mit/%s:%s\n",
		    login, uid, fullname, nickname, oa, op, hp, login, shell);
##  }
##  inquire_equel(error = "errorno")
    if (error)  {
	fprintf(out, "Ingres error %d\n", error);
	exit(MR_INGRES_ERR);
    }

##  exit

    if (fclose(out)) {
	perror("close failed");
	exit(MR_CCONFIG);
    }
    if (outf)
      fix_file(outf);
    exit(MR_SUCCESS);
}


/*
 * ingerr: (supposedly) called when Ingres indicates an error.
 * I have not yet been able to get this to work to intercept a
 * database open error.
 */
#define INGRES_DEADLOCK 4700

static int ingerr(num)
    int *num;
{
    char buf[256];
    int ingres_errno;

    switch (*num) {
    case INGRES_DEADLOCK:
	ingres_errno = MR_DEADLOCK;
	break;
    default:
	ingres_errno = MR_INGRES_ERR;
    }
    com_err(whoami, MR_INGRES_ERR, " code %d\n", *num);
    critical_alert("DCM", "Passwd build encountered INGRES ERROR %d", *num);
    exit(ingres_errno);
}
