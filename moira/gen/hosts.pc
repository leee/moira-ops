/* $Id: hosts.pc,v 1.4 1998-02-08 17:27:49 danw Exp $
 *
 * This generates the hstath.txt hosttable.
 *
 * (c) Copyright 1993-1998 by the Massachusetts Institute of Technology.
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
 */

#include <mit-copyright.h>
#include <moira.h>

#include <sys/stat.h>

#include <netinet/in.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "util.h"

EXEC SQL INCLUDE sqlca;

RCSID("$Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/gen/hosts.pc,v 1.4 1998-02-08 17:27:49 danw Exp $");

char *whoami = "hosts.gen";
char *db = "moira/moira";

int main(int argc, char **argv)
{
  FILE *out = stdout;
  char *outf = NULL, outft[64], *p, buf[256];
  struct stat sb;
  struct timeval now;
  int flag1, flag2, i;
  struct hash *aliases;
  EXEC SQL BEGIN DECLARE SECTION;
  int id;
  char name[65], vendor[33], model[33], os[33], addr[17];
  EXEC SQL END DECLARE SECTION;

  EXEC SQL CONNECT :db;

  if (argc == 2)
    {
      if (stat(argv[1], &sb) == 0)
	{
	  if (ModDiff(&flag1, "machine", sb.st_mtime) ||
	      ModDiff(&flag2, "subnet", sb.st_mtime))
	    exit(MR_DATE);
	  if (flag1 < 0 && flag2 < 0)
	    {
	      fprintf(stderr, "File %s does not need to be rebuilt.\n",
		      argv[1]);
	      exit(MR_NO_CHANGE);
	    }
	}
      outf = argv[1];
      sprintf(outft, "%s~", outf);
      if (!(out = fopen(outft, "w")))
	{
	  fprintf(stderr, "unable to open %s for output\n", outf);
	  exit(MR_OCONFIG);
	}
    }
  else if (argc != 1)
    {
      fprintf(stderr, "usage: %s [outfile]\n", argv[0]);
      exit(MR_ARGS);
    }
  else
    outf = NULL;

  EXEC SQL WHENEVER SQLERROR GOTO sqlerr;

  gettimeofday(&now, NULL);

  fprintf(out, "; MIT Network Host Table\n;\n");
  fprintf(out, "; \t%cAuthor: $\n", '$');
  fprintf(out, "; \t%cDate: $\n", '$');
  fprintf(out, "; \t%cRevision: $\n;\n", '$');
  fprintf(out, "; Host table generated by Moira at %s;\n",
	  ctime(&now.tv_sec));

  EXEC SQL DECLARE y CURSOR FOR SELECT mach_id, name FROM hostalias;
  EXEC SQL OPEN y;
  aliases = create_hash(1001);
  while (1)
    {
      EXEC SQL FETCH y INTO :id, :name;
      if (sqlca.sqlcode)
	break;
      if (id == 0)
	continue;
      if (!*strtrim(name))
	continue;
      if ((i = strlen(name)) < 9 || !strchr(name, '.') ||
	  strcmp(strchr(name, '.'), ".MIT.EDU"))
	{
	  fprintf(stderr, "Ignoring alias %s\n", name);
	  continue;
	}
      else
	name[i - 8] = 0;
      if ((p = hash_lookup(aliases, id)))
	{
	  sprintf(buf, "%s,%s", p, name);
	  hash_update(aliases, id, strdup(buf));
	  free(p);
	}
      else
	hash_store(aliases, id, strdup(name));
    }

  EXEC SQL DECLARE x CURSOR FOR SELECT
    name, mach_id, vendor, model, os, address
    FROM machine WHERE status = 1 ORDER BY address;
  EXEC SQL OPEN x;
  while (1)
    {
      EXEC SQL FETCH x INTO :name, :id, :vendor, :model, :os, :addr;
      if (sqlca.sqlcode)
	break;
      if (id == 0)
	continue;
      if (!*strtrim(name))
	continue;
      if ((i = strlen(name)) < 9 || !strchr(name, '.') ||
	  strcmp(strchr(name, '.'), ".MIT.EDU"))
	{
	  fprintf(stderr, "Ignoring machine %s\n", name);
	  continue;
	}
      else
	name[i - 8] = 0;
      strtrim(vendor);
      strtrim(model);
      strtrim(os);
      strtrim(addr);
      if (*addr == 0 || inet_addr(addr) == -1)
	continue;
      if ((p = hash_lookup(aliases, id)))
	sprintf(buf, "%s,%s", name, p);
      else
	strcpy(buf, name);
      fprintf(out, "HOST : %s : %s : ", addr, buf);
      if ((*vendor || *model) && *os)
	{
	  if (*vendor && *model)
	    fprintf(out, "%s/%s : %s :\n", vendor, model, os);
	  else
	    fprintf(out, "%s%s : %s :\n", vendor, model, os);
	}
      else
	fputs("\n", out);
    }

  EXEC SQL CLOSE x;

  EXEC SQL COMMIT;

  fprintf(out, "; End of automatically generated host table\n");
  if (fclose(out))
    {
      perror("close failed");
      exit(MR_CCONFIG);
    }
  if (outf)
    fix_file(outf);
  exit(MR_SUCCESS);

sqlerr:
  db_error(sqlca.sqlcode);
  exit(MR_DBMS_ERR);
}
