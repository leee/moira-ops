/* $Header: /afs/.athena.mit.edu/astaff/project/moiradev/repository/moira/gen/aliases.qc,v 1.13 1990-03-07 14:38:17 mar Exp $
 *
 * This generates the /usr/lib/aliases mail aliases file for the mailhub.
 * The aliases file will contain:
 *	user pobox entries
 *	maillist expansions
 *	sublists of maillists
 *
 *  (c) Copyright 1988 by the Massachusetts Institute of Technology.
 *  For copying and distribution information, please see the file
 *  <mit-copyright.h>.
 */


#include <mit-copyright.h>
#include <stdio.h>
#include <string.h>
#include <sms.h>
#include <sms_app.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>


#define ML_WID	72
#define AL_MAX_WID 896

char *divide = "########################################################################";
extern int errno;
char *whoami = "aliases.gen";
char *ingres_date_and_time();
FILE *out;

main(argc, argv)
int argc;
char **argv;
{
    long tm = time(NULL);
    char filename[64], *targetfile;
    struct stat sb;
##  int flag1, flag2, flag3;
##  char *filetime;
    int ingerr();

    out= stdout;
    IIseterr(ingerr);
    initialize_sms_error_table();
##  ingres sms
##  set lockmode session where level = table

    if (argc == 2) {
	if (stat(argv[1], &sb) == 0) {
	    filetime = ingres_date_and_time(sb.st_mtime);
##	    retrieve (flag1 = int4(interval("min",tblstats.modtime - filetime)))
##		where tblstats.table = "list"
##	    retrieve (flag2 = int4(interval("min",tblstats.modtime - filetime)))
##		where tblstats.table = "imembers"
##	    retrieve (flag3 = int4(interval("min",tblstats.modtime - filetime)))
##		where tblstats.table = "users"
	    if (flag1 < 0 && flag2 < 0 && flag3 < 0) {
		fprintf(stderr, "File %s does not need to be rebuilt.\n",
			argv[1]);
		exit(SMS_NO_CHANGE);
	    }
	}
	targetfile = argv[1];
	sprintf(filename, "%s~", targetfile);
	if ((out = fopen(filename, "w")) == NULL) {
	    fprintf(stderr, "unable to open %s for output\n", filename);
	    exit(SMS_OCONFIG);
	}
    } else if (argc != 1) {
	fprintf(stderr, "usage: %s [outfile]\n", argv[0]);
	exit(SMS_ARGS);
    }

    fprintf(out, "%s\n# Aliases File Extract of %s", divide, ctime(&tm));
    fprintf(out, "# This file is automatically generated, do not edit it directly.\n%s\n\n", divide);

##  begin transaction
    get_info();
##  end transaction
##  exit

    fprintf(stderr, "Dumping information\n");
    do_mlists(out);
    do_poboxes(out);

    fprintf(out, "\n%s\n# End of aliases file\n%s\n", divide, divide);


    if (fclose(out)) {
	perror("close failed");
	exit(SMS_CCONFIG);
    }

    if (argc == 2)
      fix_file(targetfile);
    exit(SMS_SUCCESS);
}


/*
 * ingerr: (supposedly) called when Ingres indicates an error.
 * I have not yet been able to get this to work to intercept a
 * database open error.
 */
#define INGRES_DEADLOCK 4700

static int ingerr(num)
    int *num;
{
    char buf[256];
    int ingres_errno;

    switch (*num) {
    case INGRES_DEADLOCK:
	ingres_errno = SMS_DEADLOCK;
	break;
    default:
	ingres_errno = SMS_INGRES_ERR;
    }
    com_err(whoami, SMS_INGRES_ERR, " code %d\n", *num);
    critical_alert("DCM", "Alias build encountered INGRES ERROR %d", *num);
    exit(ingres_errno);
}


struct hash *users, *machines, *strings, *lists;
struct user {
    char login[9];
    char *pobox;
};
struct member {
    struct member *next;
    char *name;
    int list_id;
};
struct list {
    char *name;
    char maillist;
    char acl_t;
    char *description;
    int acl_id;
    struct member *m;
};


get_info()
##{
##  int id, maillistp, acl, pid, bid, mid;
##  char name[129], type[9], buf[257];
    char *s;
    register struct user *u;
    register struct list *l;
    register struct member *m;
    register struct list *memberlist;

    /* get locks */
##  retrieve (buf = list.modtime) where list.list_id = 0
##  retrieve (buf = users.modtime) where users.users_id = 0

    fprintf(stderr, "Loading machines\n");
    machines = create_hash(1000);
##  retrieve (id = machine.mach_id, name = machine.#name) {
      if (s = index(name, '.'))
	*s = 0;
#ifdef ATHENA
      strcat(name, ".LOCAL");
#endif
      hash_store(machines, id, strsave(name));
##  }

    fprintf(stderr, "Loading strings\n");
    strings = create_hash(2000);
##  retrieve (id = strings.string_id, name = strings.string) {
	hash_store(strings, id, strsave(strtrim(name)));
##  }

    fprintf(stderr, "Loading users\n");
    users = create_hash(12001);
##  range of u is users
##  retrieve (id = u.users_id, name = u.login, type = u.potype,
##	      pid = u.pop_id, bid = u.box_id) 
##    	where u.status = 1 or u.status = 5 or u.status = 6 {
	u = (struct user *) malloc(sizeof(struct user));
	strcpy(u->login, strtrim(name));
	if (type[0] == 'P') {
	    if (s = hash_lookup(machines, pid)) {
		sprintf(buf, "%s@%s", name, s);
		u->pobox = strsave(buf);
	    } else {
		u->pobox = (char *) NULL;
		fprintf(stderr, "User %s's pobox is on a missing machine!\n",
			u->login);
	    }
	} else if (type[0] ==  'S') {
	    if ((u->pobox = hash_lookup(strings, bid)) == NULL) {
		u->pobox = (char *) NULL;
		fprintf(stderr, "User %s's pobox string is missing!\n",
			u->login);
	    }
	} else
	  u->pobox = (char *) NULL;
	hash_store(users, id, u);
##  }

    fprintf(stderr, "Loading lists\n");
    lists = create_hash(15001);
##  range of l is list
##  retrieve (id = l.list_id, name = l.#name, maillistp = l.maillist,
##	      buf = l.desc, type = l.acl_type, acl = l.acl_id)
##    where l.active != 0 {
	l = (struct list *) malloc(sizeof(struct list));
	l->name = strsave(strtrim(name));
	l->maillist = maillistp;
	l->description = strsave(strtrim(buf));
	l->acl_t = type[0];
	l->acl_id = acl;
	l->m = (struct member *) NULL;
	hash_store(lists, id, l);
##  }


    fprintf(stderr, "Loading members\n");
##  range of m is imembers
##  retrieve (id = m.list_id, type = m.member_type, mid = m.member_id)
##    	where m.direct = 1  {
	if (l = (struct list *) hash_lookup(lists, id)) {
	    m = (struct member *) malloc(sizeof(struct member));
	    if (type[0] == 'U' &&
		(u = (struct user *) hash_lookup(users, mid))) {
		m->list_id = 0;
		m->name = u->login;
		m->next = l->m;
		l->m = m;
	    } else if (type[0] == 'L' &&
		       (memberlist = (struct list *) hash_lookup(lists, mid))) {
		m->list_id = mid;
		m->name = memberlist->name;
		m->next = l->m;
		l->m = m;
	    } else if (type[0] == 'S' &&
		       (s = hash_lookup(strings, mid))) {
		m->list_id = 0;
		m->name = s;
		m->next = l->m;
		l->m = m;
	    }
	}
##  }
##}


save_mlist(id, l, force)
int id;
register struct list *l;
int force;
{
    register struct member *m;
    struct list *l1;

    if (l->maillist == 2 ||
	(l->maillist == 0 && !force))
      return;

    if (l->m && l->m->next == NULL &&
	!strcasecmp(l->name, l->m->name)) {
	l->maillist = 0;
	return;
    }
    l->maillist = 2;
    output_mlist(id, l, out);

    if (l->acl_t == 'L' && (l1 = (struct list *)hash_lookup(lists, l->acl_id)))
      save_mlist(0, l1, 1);
    
    for (m = l->m; m; m = m->next) {
	if (m->list_id && (l1 = (struct list *)hash_lookup(lists, m->list_id)))
	  save_mlist(0, l1, 0);
    }
}


int lwid, bol, awid;

output_mlist(id, l, dummy)
int id;
register struct list *l;
int dummy;
{
    struct list *l1;
    register struct member *m;
    struct user *u;
    int id;

    put_fill(out, l->description);
    if (l->acl_t ==  'L') {
	if (l1 = (struct list *) hash_lookup(lists, l->acl_id))
	  fprintf(out, "owner-%s: %s\n", l->name, l1->name);
    } else if (l->acl_t ==  'U') {
	if (u = (struct user *) hash_lookup(users, l->acl_id))
	  fprintf(out, "owner-%s: %s\n", l->name, u->login);
    }

    fprintf(out, "%s: ", l->name);
    lwid = strlen(l->name) + 2;
    bol = 1;
    for (m = l->m; m; m = m->next)
      do_member(out, m->name);
    if (l->m == (struct member *)NULL)
      fprintf(out, "/dev/null");
    fprintf(out, "\n\n");
}


/* Extract mailing lists.  Make a list of all mailinglists, then
 * process them, adding any sub-lists or acl lists to the list of lists
 * to be processed.  If further sublists are encountered, repeat...
 */

do_mlists(out)
FILE *out;
{
    fprintf(out, "\n%s\n# Mailing lists\n%s\n", divide, divide);
    hash_step(lists, save_mlist, 0);
}


/* print out strings separated by commas, doing line breaks as appropriate */

do_member(out, s)
FILE *out;
register char *s;
{
    register wwid;
    static int cont = 1;

    wwid = strlen(s);

    if (!bol && awid + wwid + 2 > AL_MAX_WID) {
	fprintf(out, ",\n\tcontinuation-%d\ncontinuation-%d: ", cont, cont);
	cont++;
	awid = lwid = 17 + wwid;
	fputs(s, out);
	return;
    }

    if (bol) {
	lwid += wwid;
	awid = lwid;
	fputs(s, out);
	bol = 0;
	return;
    }
    if (lwid + wwid + 2 > ML_WID) {
	fprintf(out, ",\n\t%s", s);
	awid += lwid + wwid + 2;
	lwid = wwid + 8;
	return;
    }
    lwid += wwid + 2;
    fprintf(out, ", %s", s);
}

do_pobox(id, u, out)
int id;
register struct user *u;
FILE *out;
{
    if (u->pobox)
      fprintf(out, "%s: %s\n", u->login, u->pobox);
}


/* Do user poboxes.  Just step through the users table, and print any
 * we extracted earlier.
 */

do_poboxes(out)
FILE *out;
{
    register char *p;
    char *index();

    fprintf(out, "\n%s\n# User Poboxes\n%s\n", divide, divide);

    hash_step(users, do_pobox, out);
}


put_fill(aliases, string)
FILE *aliases;
register char *string;
{
    register char *c;
    register int lwid;
    register int wwid;

    if (*string == 0) return;
    fputs("#  ", aliases);
    lwid = 3;

    while (1) {
	while (*string && *string == ' ') string++;
	c = (char *)index(string, ' ');
	if (c == 0) {
	    wwid = strlen(string);
	} else {
	    wwid = c - string;
	    *c = 0;
	}

	if ((lwid + wwid) > ML_WID) {
	    fputs("\n#  ", aliases);
	    lwid = 3;
	    fputs(string, aliases);
	} else {
	    fputs(string, aliases);
	}

	if (c == (char *)0) break;
	/* add a space after the word */
	(void) fputc(' ', aliases);
	wwid++;
	lwid += wwid;
	string += wwid;
	/* add another if after a period */
	if (*--c == '.') {
	    (void) fputc(' ', aliases);
	    lwid++;
	}
    }

    (void) fputc('\n', aliases);
}
